(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["BloxHack"] = factory();
	else
		root["BloxHack"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../public/js/BehaviorBounce.js":
/*!**************************************!*\
  !*** ../public/js/BehaviorBounce.js ***!
  \**************************************/
/*! exports provided: BehaviorLine, BehaviorBounce, BehaviorOscillate, BehaviorWander, BehaviorStare */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorLine\", function() { return BehaviorLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorBounce\", function() { return BehaviorBounce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorOscillate\", function() { return BehaviorOscillate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorWander\", function() { return BehaviorWander; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorStare\", function() { return BehaviorStare; });\nclass BehaviorLine extends THREE.Line2 {\n\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tlet geometry = new THREE.LineGeometry();\n\t\tlet matLine = new THREE.LineMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\tlinewidth: 5, // in pixels\n\t\t\tvertexColors: THREE.VertexColors,\n\t\t\tdashed: false\n\t\t});\n\t\tmatLine.resolution.set(window.innerWidth, window.innerHeight);\n\t\tsuper(geometry, matLine);\n\t\tthis.myGeometry = geometry;\n\t\tthis.first = blox.query(props.first);\n\t\tthis.second = blox.query(props.second);\n\t}\n\n\ton_tick(args) {\n\n\t\tif (!this.first || !this.second) return;\n\n\t\tlet a = this.first.mesh.position;\n\t\tlet b = this.second.mesh.position;\n\n\t\tlet geometry = this.myGeometry;\n\t\tlet positions = [];\n\t\tlet colors = [];\n\t\t//let points = hilbert3D( new THREE.Vector3( 0, 0, 0 ), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );\n\t\tlet points = [a, b];\n\t\tlet spline = new THREE.CatmullRomCurve3(points);\n\t\tlet divisions = Math.round(12 * points.length);\n\t\tlet color = new THREE.Color();\n\t\tfor (let i = 0, l = divisions; i < l; i++) {\n\t\t\tlet point = spline.getPoint(i / l);\n\t\t\tpositions.push(point.x, point.y, point.z);\n\t\t\tcolor.setHSL(i / l, 1.0, 0.5);\n\t\t\tcolors.push(color.r, color.g, color.b);\n\t\t}\n\t\tgeometry.setPositions(positions);\n\t\tgeometry.setColors(colors);\n\n\t\tthis.computeLineDistances();\n\t\tgeometry.verticesNeedUpdate = true;\n\t}\n\n}\n\nclass BehaviorBounce {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tthis.thrust = props.thrust ? new THREE.Vector3(props.thrust.x, props.thrust.y, props.thrust.z) : new THREE.Vector3();\n\t\tthis.force = props.force ? new THREE.Vector3(props.force.x, props.force.y, props.force.z) : new THREE.Vector3();\n\t\t// TODO it does expect properties to exist... maybe it should force requirements to exist if not present\n\t\t// TODO so maybe it should also add itself to the blox? can it add duplicate named entries?\n\t\t// blox.register(this)\n\t}\n\ton_tick(args) {\n\t\tif (!args.blox.mesh) return;\n\t\tthis.force.add(this.thrust);\n\t\targs.blox.mesh.position.add(this.force);\n\t\tif (args.blox.mesh.position.y < 2) {\n\t\t\targs.blox.mesh.position.y = 2;\n\t\t\tthis.force.y = 0.5;\n\t\t}\n\t}\n}\n\nclass BehaviorOscillate {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tthis.angle = 0;\n\t}\n\ton_tick(args) {\n\t\tif (!args.blox.mesh) return; // TODO more error checking\n\t\tlet rad = 30;\n\t\tthis.angle += 0.01;\n\t\targs.blox.mesh.position.set(Math.sin(this.angle) * rad, 3, Math.cos(this.angle) * rad);\n\t}\n}\n\nclass BehaviorWander {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tthis.thrust = props.thrust ? new THREE.Vector3(props.thrust.x, props.thrust.y, props.thrust.z) : new THREE.Vector3();\n\t\tthis.force = props.force ? new THREE.Vector3(props.force.x, props.force.y, props.force.z) : new THREE.Vector3();\n\t}\n\ton_tick(args) {\n\t\tif (!args.blox.mesh) return;\n\t\t// pick somewhere occasionally\n\t\tif (!this.focus || Math.random() < 0.011) {\n\t\t\tthis.focus = new THREE.Vector3(Math.random() * 20 - 10, Math.random() * 20, Math.random() * 20 - 10);\n\t\t}\n\t\t// accelerate towards it if far away\n\t\tthis.thrust.x = (this.focus.x - blox.mesh.position.x) * 0.01 * interval;\n\t\tthis.thrust.y = (this.focus.y - blox.mesh.position.y) * 0.01 * interval;\n\t\tthis.thrust.z = (this.focus.z - blox.mesh.position.z) * 0.01 * interval;\n\t\tthis.force.add(this.thrust);\n\t\targs.mesh.position.add(this.force); // TODO update to use a newer force philosophy or consolidate\n\t}\n}\n\nclass BehaviorStare {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tthis.props = props;\n\t\tthis.focus = blox.query(props);\n\t}\n\ton_tick(args) {\n\t\tif (this.focus && this.focus.mesh && args.blox.mesh) {\n\t\t\targs.blox.mesh.lookAt(this.focus.mesh.position);\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorBounce.js?");

/***/ }),

/***/ "../public/js/BehaviorCamera.js":
/*!**************************************!*\
  !*** ../public/js/BehaviorCamera.js ***!
  \**************************************/
/*! exports provided: BehaviorCamera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorCamera\", function() { return BehaviorCamera; });\nclass BehaviorCamera extends THREE.PerspectiveCamera {\n\tconstructor(args) {\n\t\tlet props = args.description || {};\n\t\tlet blox = args.blox;\n\t\tlet camera = super(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n\t\tlet position = props.position || { x: 0, y: 1, z: 10 };\n\t\tlet lookat = props.lookat || { x: 0, y: 1, z: 0 };\n\t\tcamera.position.set(position.x, position.y, position.z);\n\t\tcamera.lookAt(lookat.x, lookat.y, lookat.z);\n\t\tvar light = new THREE.PointLight(0xffffff, 1, 100);\n\t\tcamera.add(light);\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorCamera.js?");

/***/ }),

/***/ "../public/js/BehaviorCollide.js":
/*!***************************************!*\
  !*** ../public/js/BehaviorCollide.js ***!
  \***************************************/
/*! exports provided: BehaviorCollide */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorCollide\", function() { return BehaviorCollide; });\n\nlet collidants = [];\n\nclass BehaviorCollide {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tif (!props.layer) props.layer = 1;\n\t\tif (!props.filter) props.filter = 1;\n\t\tif (!props.proximity) props.proximity = 1;\n\t\tcollidants.push({ props: props, blox: blox });\n\t}\n\ton_tick(args) {\n\t\t// test everybody\n\t\tfor (let i = 0; i < collidants.length; i++) {\n\t\t\tfor (let j = i + 1; j < collidants.length; j++) {\n\t\t\t\tlet a = collidants[i];\n\t\t\t\tlet b = collidants[j];\n\t\t\t\t// TODO it is fragile code wise to look specifically for a mesh - should use blox.findByProperty(\"isObject3D\")\n\t\t\t\tif (!a.blox.mesh || !b.blox.mesh) continue;\n\t\t\t\t// May only collide if layer masks overlap\n\t\t\t\tif (!(a.props.layer & b.props.layer)) continue;\n\t\t\t\tlet dist = a.blox.mesh.position.distanceTo(b.blox.mesh.position);\n\t\t\t\tlet near = a.props.proximity + b.props.proximity;\n\t\t\t\tif (dist < near) {\n\t\t\t\t\t// May only report if filters also succeed\n\t\t\t\t\tif (a.props.filter & b.props.layer) {\n\t\t\t\t\t\ta.blox.on_event({ name: \"on_overlap\", blox: a.blox, other: b.blox });\n\t\t\t\t\t}\n\t\t\t\t\tif (b.props.filter & a.props.layer) {\n\t\t\t\t\t\tb.blox.on_event({ name: \"on_overlap\", blox: b.blox, other: a.blox });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist < near && !a.latched) {\n\t\t\t\t\ta.latched = true;\n\t\t\t\t\ta.blox.on_event({ name: \"on_enter\", blox: a.blox, other: b.blox });\n\t\t\t\t\tb.blox.on_event({ name: \"on_enter\", blox: b.blox, other: a.blox });\n\t\t\t\t} else if (dist >= 2) a.latched = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorCollide.js?");

/***/ }),

/***/ "../public/js/BehaviorEmitter.js":
/*!***************************************!*\
  !*** ../public/js/BehaviorEmitter.js ***!
  \***************************************/
/*! exports provided: BehaviorEmitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorEmitter\", function() { return BehaviorEmitter; });\nclass BehaviorEmitter {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tif (!props || !props.target) {\n\t\t\tconsole.error(\"You have to specify a target\");\n\t\t\treturn;\n\t\t}\n\t\tlet target = blox.query(props.target);\n\t\tif (!target || !target.parent) {\n\t\t\tconsole.error(\"Target is not found\");\n\t\t\treturn;\n\t\t}\n\t\tlet count = props.count || 10;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\t// randomize name\n\t\t\ttarget.description.name = props.name + i;\n\t\t\t// copy\n\t\t\tlet fresh = target.parent.group.push(target.description);\n\t\t\t// randomly place - TODO parameterize\n\t\t\tlet x = Math.random() * 10 - 5;\n\t\t\tlet y = 0;\n\t\t\tlet z = Math.random() * 10 - 5;\n\t\t\tif (fresh.mesh) fresh.mesh.position.set(x, y, z);\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorEmitter.js?");

/***/ }),

/***/ "../public/js/BehaviorHeart.js":
/*!*************************************!*\
  !*** ../public/js/BehaviorHeart.js ***!
  \*************************************/
/*! exports provided: BehaviorHeart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorHeart\", function() { return BehaviorHeart; });\n/* harmony import */ var _BehaviorMesh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BehaviorMesh.js */ \"../public/js/BehaviorMesh.js\");\n\nlet heart_geometry = 0;\n\n\n\nclass BehaviorHeart extends _BehaviorMesh_js__WEBPACK_IMPORTED_MODULE_0__[\"BehaviorMesh\"] {\n\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tsuper(args);\n\t}\n\n\tsetCustomGeometry() {\n\t\tif (heart_geometry) return heart_geometry;\n\t\tlet x = 0,\n\t\t    y = 0;\n\t\tlet shape = new THREE.Shape();\n\t\tshape.moveTo(x + .5, y + .5);\n\t\tshape.bezierCurveTo(x + .5, y + .5, x + .4, y, x, y);\n\t\tshape.bezierCurveTo(x - .6, y, x - .6, y + .7, x - .6, y + .7);\n\t\tshape.bezierCurveTo(x - .6, y + 1.1, x - .3, y + 1.54, x + .5, y + 1.9);\n\t\tshape.bezierCurveTo(x + 1.2, y + 1.54, x + 1.6, y + 1.1, x + 1.6, y + .7);\n\t\tshape.bezierCurveTo(x + 1.6, y + .7, x + 1.6, y, x + 1.0, y);\n\t\tshape.bezierCurveTo(x + .7, y, x + .5, y + .5, x + .5, y + .5);\n\t\t//let extrudeSettings = { depth: 1, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 }\n\t\t//heart_geometry = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings )\n\t\t//heart_geometry = new THREE.ShapeGeometry( shape )\n\t\theart_geometry = new THREE.ShapeBufferGeometry(shape);\n\t\tthis.madeGeometry = true;\n\t\treturn heart_geometry;\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorHeart.js?");

/***/ }),

/***/ "../public/js/BehaviorIntent.js":
/*!**************************************!*\
  !*** ../public/js/BehaviorIntent.js ***!
  \**************************************/
/*! exports provided: BehaviorIntent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorIntent\", function() { return BehaviorIntent; });\n\n///\n/// BehaviorMotion\n///\n/// Simplest motion support with some minimal fake \"inverse kinematics\" so that things can have a sense of heft and be directed\n/// Includes some simple collision\n/// Includes semantic concepts of destination\n/// Currently conflates a concept of sequencing events over time\n///\n/// Rudiments of motion:\n///\n///\t\t\t- position\n///\t\t\t- quaternion\n///\t\t\t- velocity - objects visually exhibit a linear and angular velocity [ there is no explicit acceleration property ]\n///\t\t\t- angular velocity\n///\t\t\t- forces - objects have forces being applied to them constantly over every frame that are applied to their velocity\n///\t\t\t- friction - objects have a friction that dampens velocity over time\n///\t\t\t- mass - objects have a mass that forces are divided by over time\n///\t\t\t- impulses - objects can accept impulses that immediately are applied to the velocity\n///\t\t\t- inverse kinematics - objects can be asked to go to a place and apply forces to get there at a speed\n///\t\t\t- speed - affect inverse kinematics\n///\t\t\t- helpers - radial explosions, wind, gravity and other kinds of forces can be easily declared over objects\n///\n/// Collision (TBD):\n///\t\t\t- collision -> crude sphere proximity as a default - not using real physics engine\n///\n/// Semantics:\n///\t\t\t- expressions of target destinations as abstractions (go to the tree)\n///\t\t\t- modifiers of destination (be at eye level)\n///\n/// Examples:\n///\t\t\t* drive a player avatar around easily\n///\t\t\t- make a bunch of 3d letters explode\n///\t\t\t- make a camera go to a place and look at the player\n///\t\t\t- make an object go to a place that is abstract\n///\t\t\t- walk a path of breadcrumbs - each collision event sets the next goal\n///\t\t\t- choreograph a story over time with delays easily with deferred event sequencing and proximity collisions\n///\t\t\t- apply the same choreography to many objects\n///\n\n\n// TODO I'd like to start importing 3js now instead of just assuming it is around\n// import * as THREE from 'three';\n\n\nclass BehaviorIntent {\n\n\tconstructor(args) {\n\t\t// pass to ourselves as a reset message for convenience so event handlers can easily invoke changes\n\t\tthis.blox = args.blox;\n\t\tthis.on_reset(args);\n\t}\n\n\ton_reset(args) {\n\t\tif (args.description instanceof Array) {\n\t\t\tthis.sequence_counter = 0;\n\t\t\tthis.sequence_latch = 0;\n\t\t\tthis.sequence = args.description;\n\t\t\treturn;\n\t\t}\n\t\tthis.on_do(args);\n\t}\n\n\ton_do(args) {\n\n\t\tlet props = args.description || {};\n\t\tlet blox = this.blox;\n\n\t\t// sequence time? (to loop programs themselves)\n\t\tif (props.hasOwnProperty(\"reset\")) {\n\t\t\tthis.sequence_counter = parseInt(props.reset);\n\t\t\tthis.sequence_latch = 0;\n\t\t}\n\n\t\t// reset?\n\t\tif (!this.isInitialized || props.reset) {\n\t\t\tthis.isInitialized = true;\n\t\t\t// back reference to player if any (for destination modifiers like 'be at eye level')\n\t\t\tthis.player = 0;\n\t\t\t// back reference to nearest mesh if any\n\t\t\tthis.mesh = blox ? blox.query({ property: \"isObject3D\" }) : 0;\n\t\t\t// position right now\n\t\t\tthis.position = this.mesh ? this.mesh.position.clone() : new THREE.Vector3();\n\t\t\t// orientation right now\n\t\t\tthis.quaternion = this.mesh ? this.mesh.quaternion.clone() : new THREE.Quaternion();\n\t\t\t// velocity right now - can be thought of as momentum - and is a product of forces over time / mass\n\t\t\tthis.velocity = new THREE.Vector3();\n\t\t\t// angular velocity right now\n\t\t\tthis.angular = new THREE.Quaternion();\n\t\t\t// keep forces in a forces bucket so that multiple forces can act on something at once\n\t\t\tthis.forces = {};\n\t\t\t// universal friction applied to dampen all forces over time\n\t\t\tthis.friction = 0.9;\n\t\t\t// a rate concept for inverse kinematics\n\t\t\tthis.speed = 1.0;\n\t\t\t// mass\n\t\t\tthis.mass = 1.0;\n\n\t\t\t// don't have any particular ik destination to start with\n\t\t\tthis.destination = 0;\n\t\t\tthis.facing = 0;\n\t\t\tthis.inverse_kinematics = false;\n\t\t\t// don't be doing any physics at all unless there are any forces being applied\n\t\t\tthis.any_kinematics = false;\n\t\t\t// don't have any modifiers to start with; these are all explicit for now, I may coalese into a smarter concept\n\t\t\tthis.modifier_eyelevel = 0;\n\t\t\tthis.modifier_ground = 0;\n\t\t\tthis.modifier_wall = 0;\n\t\t\tthis.modifier_billboard = 0;\n\t\t\tthis.modifier_tagalong = 0;\n\t\t}\n\n\t\t// player?\n\t\tif (props.hasOwnProperty(\"player\")) {\n\t\t\tthis.player = blox ? blox.query(props.player) : 0;\n\t\t}\n\n\t\t// hammer in an absolute position in x,y,z or from an existing entity (such as a previously placed breadcrumb)\n\t\tif (props.hasOwnProperty(\"position\")) {\n\t\t\tif (typeof props.position === \"string\") {\n\t\t\t\tlet mesh = blox ? blox.query({ name: props.position, property: isObject3D }) : 0;\n\t\t\t\tif (mesh) {\n\t\t\t\t\tthis.position = mesh.position.clone();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.position = new THREE.Vector3(props.position.x, props.position.y, props.position.z);\n\t\t\t}\n\t\t}\n\n\t\t// remember an eventual destination (could be a target named object that may be moving) - resolved later on\n\t\tif (props.hasOwnProperty(\"destination\")) {\n\t\t\t// TODO could verify that this is a string or a Vector3\n\t\t\t// TODO could consolidate with on_goto\n\t\t\tthis.destination = props.destination;\n\t\t\tthis.any_kinematics = true;\n\t\t\tthis.inverse_kinematics = true;\n\t\t}\n\n\t\t// remember an eventual orientation\n\t\tif (props.hasOwnProperty(\"facing\")) {\n\t\t\tthis.facing = props.facing;\n\t\t}\n\n\t\t// friction? (It feels hand to have a special universal opposing force to brings things to rest)\n\t\tif (props.hasOwnProperty(\"friction\")) {\n\t\t\tthis.friction = props.friction;\n\t\t}\n\n\t\t// velocity\n\t\tif (props.hasOwnProperty(\"velocity\")) {\n\t\t\tthis.velocity = new THREE.Vector3(props.velocity.x, props.velocity.y, props.velocity.z);\n\t\t\tthis.any_kinematics = true;\n\t\t}\n\n\t\tif (props.hasOwnProperty(\"angular\")) {}\n\t\t// TODO angular - convert\n\n\n\t\t// gravity? (I feel it's handy to explicitly call out gravity as a special force... it's debatable however...)\n\t\tif (props.hasOwnProperty(\"gravity\")) {\n\t\t\tthis.forces[\"gravity\"] = new THREE.Vector3(props.gravity.x, props.gravity.y, props.gravity.z);\n\t\t\tthis.any_kinematics = true;\n\t\t}\n\n\t\t// mass\n\t\tif (props.hasOwnProperty(\"mass\")) {\n\t\t\tthis.mass = props.mass;\n\t\t}\n\n\t\t// inverse kinematics speed ratio; 1 = 1m/s - a number like 100000 would mean move very fast to destination\n\t\tif (props.hasOwnProperty(\"speed\")) {\n\t\t\tthis.speed = props.speed;\n\t\t}\n\n\t\t// ik modifier - seek a height level based on a target or number (this is a modifier on a destination)\n\t\tif (props.hasOwnProperty(\"height\")) {\n\t\t\tthis.modifier_height = props.height;\n\t\t}\n\n\t\t// ik modifier - seek some elevation on wall\n\t\tif (props.hasOwnProperty(\"wall\")) {\n\t\t\tthis.modifier_wall = props.wall;\n\t\t}\n\n\t\t// ik modifier - be in some position relative to a user - like in front of user\n\t\tif (props.hasOwnProperty(\"tagalong\")) {\n\t\t\tthis.modifier_tagalong = props.eyelevel;\n\t\t}\n\n\t\t// ik modifier - billboard to face some angle with respect to a third party such as the user\n\t\tif (props.hasOwnProperty(\"billboard\")) {\n\t\t\tthis.modifier_billboard = props.eyelevel;\n\t\t}\n\n\t\t// TODO - NEAR, ABOVE, BELOW, INSIDE, BEHIND, FACING, STARE\n\t}\n\n\t///\n\t/// notice tick event and update kinetic physics\n\t///\n\n\ton_tick(args = {}) {\n\n\t\tlet blox = args.blox || 0;\n\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// Step forward in sequence\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\tif (this.sequence) {\n\t\t\t// get seconds so far\n\t\t\tlet seconds = Math.floor(args.interval);\n\t\t\t// has there been any significant change in time?\n\t\t\tif (seconds != this.sequence_latch) {\n\t\t\t\tthis.sequence_latch = seconds;\n\t\t\t\t// perform everything at this time; TODO could accept fractional time also\n\t\t\t\tfor (let i = 0; i < this.sequence.length; i++) {\n\t\t\t\t\tlet s = this.sequence[i];\n\t\t\t\t\tif (s.time == this.sequence_counter) {\n\t\t\t\t\t\tthis.on_do({ description: s });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.sequence_counter++;\n\t\t\t}\n\t\t}\n\n\t\tthis.on_kinematics(args);\n\t}\n\n\ton_kinematics(args) {\n\n\t\tlet blox = this.blox;\n\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// Get out if no kinematics at all\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\tif (!this.any_kinematics) return;\n\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// Linear - Evaluate Destinations which will compute an inverse kinematics style set of forces to apply to the object\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\tlet mass = this.mass ? this.mass : 1;\n\t\tlet impulse = new THREE.Vector3(0, 0, 0);\n\n\t\tif (this.inverse_kinematics) {\n\n\t\t\t// Find basic destination\n\n\t\t\tlet destiny = { x: 0, y: 0, z: 0 };\n\n\t\t\tif (typeof this.destination === \"string\") {\n\t\t\t\tlet mesh = blox ? blox.query({ name: this.destination, property: \"isObject3D\" }) : 0;\n\t\t\t\tif (mesh) {\n\t\t\t\t\tdestiny = mesh.position.clone();\n\t\t\t\t\tthis.destination = destiny; // HACK just stick with the one we found and do not refind\n\t\t\t\t}\n\t\t\t\t// TODO deal with this.facing\n\t\t\t} else if (this.destination) {\n\t\t\t\tdestiny = new THREE.Vector3(this.destination.x, this.destination.y, this.destination.z);\n\t\t\t\t// TODO deal with this.facing\n\t\t\t}\n\n\t\t\t// Apply modifiers\n\t\t\t// TODO 0 is off right now ... improve\n\n\t\t\tif (this.modifier_height) {\n\t\t\t\tdestiny.y = this.modifier_height || 0;\n\t\t\t}\n\n\t\t\t// TODO - improve inverse kinematics - figure out forces to go from current position to destination at current rate of movement\n\n\t\t\timpulse.x += (destiny.x - this.position.x) / 20;\n\t\t\timpulse.y += (destiny.y - this.position.y) / 20;\n\t\t\timpulse.z += (destiny.z - this.position.z) / 20;\n\t\t}\n\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// Linear - Given forces being applied - compute a total impulse to add - this is ignoring the time interval at this stage\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\tObject.entries(this.forces).forEach(([name, force]) => {\n\t\t\timpulse.x += force.x;\n\t\t\timpulse.y += force.y;\n\t\t\timpulse.z += force.z;\n\t\t});\n\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// Linear - Given an impulse, it has to be divided by the mass\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\tthis.velocity.x += impulse.x / mass;\n\t\tthis.velocity.y += impulse.y / mass;\n\t\tthis.velocity.z += impulse.z / mass;\n\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// Linear - Dampen velocity by a universal friction\n\t\t// Given an impulse, it has to be divided by the temporal interval and it has to be divided by the mass\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\tlet universalFriction = this.friction ? this.friction : 0.9;\n\t\tlet lapsedTimeSlice = 60.0 / 1000.0; // TODO hack - assume 60fps\n\n\t\tthis.velocity.x -= this.velocity.x * universalFriction * lapsedTimeSlice;\n\t\tthis.velocity.y -= this.velocity.y * universalFriction * lapsedTimeSlice;\n\t\tthis.velocity.z -= this.velocity.z * universalFriction * lapsedTimeSlice;\n\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// Linear - Move the object\n\t\t// TODO In a physics engine this would have to be solved forward at a small time step to deal with collisions\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\tthis.position.x += this.velocity.x * lapsedTimeSlice;\n\t\tthis.position.y += this.velocity.y * lapsedTimeSlice;\n\t\tthis.position.z += this.velocity.z * lapsedTimeSlice;\n\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// Angular\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\tif (this.facing) {\n\t\t\tlet dir = new THREE.Vector3(-this.velocity.x, 0, -this.velocity.z).normalize();\n\t\t\tvar mx = new THREE.Matrix4().lookAt(dir, new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));\n\t\t\tlet q = new THREE.Quaternion().setFromRotationMatrix(mx);\n\t\t\tthis.quaternion.rotateTowards(q, 0.1);\n\t\t}\n\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\t// Copy position to mesh\n\t\t//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\tif (this.mesh) {\n\t\t\tthis.mesh.position.set(this.position.x, this.position.y, this.position.z);\n\t\t\tthis.mesh.quaternion.copy(this.quaternion);\n\t\t}\n\t}\n\n\t///\n\t/// Adjust velocity in m/s right now. Technically this is called an 'impulse'. It also turns off IK.\n\t///\n\n\ton_impulse(args) {\n\t\tlet linear = args.linear || 0;\n\t\tlet angular = args.angular || 0;\n\n\t\tthis.any_kinematics = true;\n\t\tthis.inverse_kinematics = false;\n\t\tthis.destination = 0;\n\t\tif (linear) {\n\t\t\t// rotate force to current heading and apply it to forces on object\n\t\t\tlet scratch = new THREE.Vector3(linear.x, linear.y, linear.z);\n\t\t\tscratch.applyQuaternion(this.quaternion);\n\t\t\tthis.velocity.add(scratch);\n\t\t}\n\t\tif (angular) {\n\t\t\t// get angular force as a quaternion\n\t\t\tlet q = new THREE.Quaternion();q.setFromEuler(angular);\n\t\t\t// apply to current orientation immediately\n\t\t\tthis.quaternion.multiply(q);\n\t\t}\n\t}\n\n\t///\n\t/// Go to a specific target now...\n\t///\n\n\ton_goto(args) {\n\t\tthis.destination = args.destination || 0;\n\t\tif (this.destination) {\n\t\t\tthis.any_kinematics = true;\n\t\t\tthis.inverse_kinematics = true;\n\t\t} else {\n\t\t\tthis.inverse_kinematics = false;\n\t\t}\n\t}\n\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorIntent.js?");

/***/ }),

/***/ "../public/js/BehaviorLight.js":
/*!*************************************!*\
  !*** ../public/js/BehaviorLight.js ***!
  \*************************************/
/*! exports provided: BehaviorLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorLight\", function() { return BehaviorLight; });\nclass BehaviorLight extends THREE.DirectionalLight {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\n\t\t// instance directional light\n\t\tsuper(props);\n\n\t\t// adjust scale and position\n\t\tif (props.position) this.position.set(props.position.x, props.position.y, props.position.z);\n\n\t\tthis.target.position.set(0, 0, 0);\n\t\tthis.castShadow = true;\n\n\t\t// debug - make a visible representation\n\t\tlet color = props.color || 0xFFFF00;\n\t\tlet geometry = new THREE.SphereGeometry(3, 16, 16);\n\t\tlet material = new THREE.MeshBasicMaterial({ color: color });\n\t\tlet mesh = new THREE.Mesh(geometry, material);\n\t\tthis.add(mesh);\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorLight.js?");

/***/ }),

/***/ "../public/js/BehaviorMesh.js":
/*!************************************!*\
  !*** ../public/js/BehaviorMesh.js ***!
  \************************************/
/*! exports provided: BehaviorMesh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorMesh\", function() { return BehaviorMesh; });\n\n///\n/// A mesh manager\n///\n/// TODO support active or inactive\n/// TODO should material properties be more detailed?\n///\n\nclass BehaviorMesh extends THREE.Mesh {\n\n\tconstructor(args) {\n\n\t\t// TODO I would prefer to instance and set properties in one step rather than deleting and resetting properties\n\t\tsuper();\n\n\t\t// set or reset various properties from params\n\t\tthis.on_reset(args);\n\t}\n\n\t/// set or reset qualities of this mesh\n\ton_reset(args) {\n\n\t\tlet props = args.description || {};\n\t\tif (!props) return;\n\n\t\t// support a single parameter - to the art\n\t\tif (typeof props === \"string\") props = { art: props\n\n\t\t\t// set or reset material from params if changed\n\t\t\t// - do this before the geom in case I later want to try scavenge material into gltf\n\t\t};if (!this.description || props.color != this.description.color || !this.material) {\n\t\t\tlet c = props.color || 0xff00ff;\n\t\t\tlet s = props.doublesided ? THREE.DoubleSide : 0;\n\t\t\tlet a = props.alpha ? 0 : 0;\n\t\t\tlet t = props.texture ? THREE.ImageUtils.loadTexture(props.texture) : 0;\n\t\t\tlet mat = new THREE.MeshPhongMaterial({ color: c, transparent: a, side: s, map: t });\n\t\t\tif (this.material) this.material.dispose();\n\t\t\tthis.material = mat;\n\t\t}\n\n\t\t// set or reset geometry if changed\n\t\tif (!this.madeGeometry || this.description && props.art && this.description.art != props.art) {\n\t\t\tif (props.hasOwnProperty(\"art\")) this.geometry = this.setGeometryFromString(props.art);\n\t\t}\n\n\t\tlet mesh = this;\n\n\t\tif (props.scale) {\n\t\t\tmesh.scale.set(props.scale.x, props.scale.y, props.scale.z);\n\t\t}\n\n\t\tif (props.position) {\n\t\t\tmesh.position.set(props.position.x, props.position.y, props.position.z);\n\t\t}\n\n\t\tif (props.orientation) {\n\t\t\tmesh.rotation.x = props.orientation.x * Math.PI / 180.0;\n\t\t\tmesh.rotation.y = props.orientation.y * Math.PI / 180.0;\n\t\t\tmesh.rotation.z = props.orientation.z * Math.PI / 180.0;\n\t\t}\n\n\t\tif (typeof props.visible !== 'undefined') {\n\t\t\tmesh.visible = props.visible ? true : false;\n\t\t}\n\t}\n\n\t/// set or reset geometry from a string description with special rules\n\tsetGeometryFromString(str) {\n\n\t\tthis.madeGeometry = true;\n\n\t\t// TODO must write remove if already exists in scene\n\n\t\tlet is_gltf = 0;\n\t\tlet geometry = 0;\n\n\t\tswitch (str) {\n\t\t\tcase undefined:\n\t\t\tcase 0:\n\t\t\tcase null:\n\t\t\tcase \"ignore\":\n\t\t\t\t// TODO the semantics here could use thought - perhaps a default shape is best if nothing is supplied\n\t\t\t\tgeometry = this.setCustomGeometry();\n\t\t\t\tbreak;\n\t\t\tcase \"group\":\n\t\t\t\tgeometry = null;\n\t\t\t\tbreak;\n\t\t\tcase \"box\":\n\t\t\tcase \"cube\":\n\t\t\t\tgeometry = new THREE.BoxBufferGeometry(1, 1, 1, 16, 16, 16);\n\t\t\t\tbreak;\n\t\t\tcase \"sphere\":\n\t\t\t\tgeometry = new THREE.SphereGeometry(1, 32, 32);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tis_gltf = 1;\n\t\t\t\tgeometry = new THREE.SphereGeometry(1, 16, 16);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (this.geometry) this.geometry.dispose();\n\t\tthis.geometry = geometry;\n\n\t\t// was a simple geometry\n\t\tif (!is_gltf) {\n\t\t\treturn this.geometry;\n\t\t}\n\n\t\t// actually i don't want to see it\n\t\tif (this.material) this.material.visible = false;\n\n\t\t// load the gltf\n\t\tlet url = str + \"/scene.gltf\";\n\t\tlet loader = new THREE.GLTFLoader();\n\t\tlet mesh = this;\n\n\t\tloader.load(url, gltf => {\n\n\t\t\tif (!gltf || !gltf.scene) {\n\t\t\t\treturn; // oh well it tried - doesn't matter if fails\n\t\t\t}\n\n\t\t\t// start animations\n\t\t\tif (gltf.animations && gltf.animations.length) {\n\t\t\t\tlet mixer = new THREE.AnimationMixer(gltf.scene);\n\t\t\t\tfor (let animation of gltf.animations) {\n\t\t\t\t\tmixer.clipAction(animation).play();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// center on self\n\t\t\tlet bbox = new THREE.Box3().setFromObject(gltf.scene);\n\t\t\tlet size = mesh.scale.length();\n\t\t\tlet resize = size / bbox.getSize(new THREE.Vector3()).length() * 2;\n\t\t\tlet offset = bbox.getCenter(new THREE.Vector3()).multiplyScalar(resize);\n\t\t\tgltf.scene.scale.set(resize, resize, resize);\n\t\t\tgltf.scene.position.sub(offset);\n\n\t\t\t// add to parent\n\t\t\tmesh.add(gltf.scene);\n\n\t\t\t// turn the top level material invisible to reveal the gltf only\n\t\t\t// TODO later use the top level material here\n\t\t\tif (this.material) this.material.visible = false;\n\t\t});\n\n\t\treturn this.geometry;\n\t}\n\n\t///\n\t/// may be subclassed\n\t///\n\tsetCustomGeometry() {\n\t\tconsole.error(this);\n\t\tthrow new Error('You have to implement the method setCustomGeometry!');\n\t}\n\n\t///\n\t/// notice when any children blox show up and add to 3js\n\t///\n\n\ton_add(args) {\n\t\tlet mesh = this;\n\t\tlet children = args.blox.query({ instance: THREE.Object3D, all: true });\n\t\tchildren.forEach(child => {\n\t\t\tmesh.add(child);\n\t\t});\n\t}\n\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorMesh.js?");

/***/ }),

/***/ "../public/js/BehaviorOrbit.js":
/*!*************************************!*\
  !*** ../public/js/BehaviorOrbit.js ***!
  \*************************************/
/*! exports provided: BehaviorOrbit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorOrbit\", function() { return BehaviorOrbit; });\nclass BehaviorOrbit extends THREE.OrbitControls {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\t// TODO it's a bit of a hack that this component knows or expects to find a camera in its own scope\n\t\tif (!blox.camera) {\n\t\t\tconsole.error(\"BehaviorOrbit requires a camera to be attached to the same group already\");\n\t\t}\n\t\tsuper(blox.camera);\n\t\tlet lookat = props.lookat || { x: 0, y: 1, z: 0 };\n\t\tthis.target = new THREE.Vector3(lookat.x, lookat.y, lookat.z);\n\t\tthis.minDistance = props.minDistance || 50;\n\t\tthis.maxDistance = props.maxDistance || 500;\n\t\tthis.update();\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorOrbit.js?");

/***/ }),

/***/ "../public/js/BehaviorParticles.js":
/*!*****************************************!*\
  !*** ../public/js/BehaviorParticles.js ***!
  \*****************************************/
/*! exports provided: BehaviorParticles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorParticles\", function() { return BehaviorParticles; });\n\n///\n/// A rudimentary particle effects engine that acts on 3d geometries\n///\n/// There are other engines which act on points and exploit shaders - it may be worth migrating to one of those\n///\n/// https://github.com/a-jie/three.proton\n/// https://tympanus.net/codrops/2019/01/17/interactive-particles-with-three-js/\n///\n///\n\n///\n/// Particle state tracking\n///\n\nclass Particle {\n\n\tconstructor(props, parentBehaviorMesh) {\n\n\t\t// re-instance and then somewhat manually associate the behavior with the threejs scene graph\n\t\t// TODO it would be nicer to create full blown blobs - it is a bit of a hack to clone behaviors\n\t\tthis.mesh = new parentBehaviorMesh.constructor(parentBehaviorMesh.description, 0);\n\t\tparentBehaviorMesh.add(this.mesh);\n\n\t\tthis.reset(props);\n\t}\n\n\treset(props) {\n\t\t// lifespan\n\n\t\tlet longevity = props.longevity || { min: 50, max: 100 };\n\t\tthis.life = this.lifestart = Math.random() * (longevity.max - longevity.min) + longevity.min;\n\n\t\t// gravity dir\n\n\t\tthis.gravity = props.gravity || new THREE.Vector3(0, -1, 0);\n\t\tthis.friction = props.friction || new THREE.Vector3(0.9, 0.9, 0.9);\n\n\t\t// starting radius cloud\n\n\t\tlet offset = props.offset || { x: 0, y: 0, z: 0 };\n\t\tlet radius = props.radius || 1;\n\n\t\tthis.position = new THREE.Vector3(offset.x + Math.random() * radius, offset.y + Math.random() * radius, offset.z + Math.random() * radius);\n\n\t\t// starting force direction\n\n\t\tlet speed = Math.random() * (props.speed.max - props.speed.min) + props.speed.min;\n\n\t\tlet nozzle = props.nozzle || { axis1: -10, axis2: 10, spin1: 0, spin2: 360\n\n\t\t\t// get vector pointing up of the speed we want\n\t\t};let v = new THREE.Vector3(0, 1 * speed, 0);\n\t\t// get angle on z to rotate that by - a small range would be a small declination\n\t\tlet a = Math.random() * (nozzle.axis2 - nozzle.axis1) + nozzle.axis1;\n\t\t// rotate it by that much\n\t\tv.applyAxisAngle(new THREE.Vector3(0, 0, 1), a * Math.PI / 180);\n\t\t// now take the result and sweep it around the vertical spin axis\n\t\tlet b = Math.random() * (nozzle.spin2 - nozzle.spin1) + nozzle.spin1;\n\t\tv.applyAxisAngle(new THREE.Vector3(0, 1, 0), b * Math.PI / 180);\n\t\tthis.velocity = v;\n\n\t\t// pick a tumble orientation\n\n\t\tthis.tumbleTime = 0;\n\n\t\t// fiddle with scale and color - TODO later get from params\n\t\t{\n\t\t\tlet r = Math.floor(Math.random() * 100 + 135);\n\t\t\tlet g = Math.floor(Math.random() * 100 + 19);\n\t\t\tlet b = Math.floor(Math.random() * 100 + 101);\n\t\t\tlet c = r * 65536 + g * 256 + b;\n\t\t\tlet s = Math.random() + 1;\n\t\t\t// build up properties to write\n\t\t\tlet modifiers = {\n\t\t\t\tart: \"ignore\",\n\t\t\t\tcolor: c,\n\t\t\t\tscale: { x: s, y: s, z: s },\n\t\t\t\tdoublesided: 1,\n\t\t\t\ttransparent: 1\n\t\t\t\t// modify the mesh\n\t\t\t};this.mesh.on_reset({ description: modifiers });\n\t\t}\n\n\t\t// force tick it ahead to get the properties into the next refresh\n\t\tthis.on_tick({ interval: 0 });\n\t}\n\n\ton_tick(args) {\n\n\t\t// age\n\t\tif (this.life < 0) {\n\t\t\tthis.mesh.visible = false;\n\t\t\tthis.mesh.position.set(0, 0, 0);\n\t\t\treturn;\n\t\t}\n\t\tthis.life--;\n\n\t\t// dampen current velocity and add forces\n\t\tlet seconds = 0.001;\n\t\tthis.velocity.x = this.velocity.x * this.friction.x + this.gravity.x * seconds;\n\t\tthis.velocity.y = this.velocity.y * this.friction.y + this.gravity.y * seconds;\n\t\tthis.velocity.z = this.velocity.z * this.friction.z + this.gravity.z * seconds;\n\n\t\t// update position by velocity\n\t\tthis.position.x += this.velocity.x;\n\t\tthis.position.y += this.velocity.y;\n\t\tthis.position.z += this.velocity.z;\n\n\t\t// move\n\t\tthis.mesh.visible = true;\n\t\tthis.mesh.position.set(this.position.x, this.position.y, this.position.z);\n\n\t\t// tumble\n\n\t\tif (--this.tumbleTime < 0 || !this.tumbleAxis) {\n\t\t\tthis.tumbleTime = Math.floor(Math.random() * 50);\n\t\t\tthis.tumbleAxis = new THREE.Vector3(Math.random() * 10, Math.random() * 10, Math.random * 10).normalize();\n\t\t}\n\t\tthis.mesh.rotateOnAxis(this.tumbleAxis, 0.1);\n\n\t\t// TODO opacity and color change\n\t\t//var colorHSL = this.colorTween.lerp( this.age );\n\t\t//this.color = new THREE.Color().setHSL( colorHSL.x, colorHSL.y, colorHSL.z );\n\n\t\tthis.mesh.material.opacity = 1 - (this.lifestart - this.life) / this.lifestart;\n\t}\n\n}\n\n///\n/// A behavior that adds particles\n///\n///\n\nclass BehaviorParticles {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tthis.props = props;\n\t\tthis.particles = [];\n\t\tthis.rateCount = 0;\n\t\tthis.mesh = blox.query({ property: \"isObject3D\" });\n\t\tif (!this.mesh) {\n\t\t\tconsole.error(\"Particles need to act on a 3d example object\");\n\t\t\treturn;\n\t\t}\n\t\tthis.mesh.material.visible = false;\n\t}\n\ton_tick(args) {\n\t\tif (!this.mesh) return;\n\n\t\t// visit all particles\n\t\tlet reusable = [];\n\t\tlet active = 0;\n\n\t\tfor (let i = 0; i < this.particles.length; i++) {\n\n\t\t\t// get a particle\n\t\t\tlet particle = this.particles[i];\n\n\t\t\t// ignore if aged out\n\t\t\tif (particle.life < 0) {\n\t\t\t\tparticle.mesh.visible = false;\n\t\t\t\treusable.push(particle);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// update\n\t\t\tparticle.on_tick(args);\n\t\t\tactive++;\n\t\t}\n\n\t\t// accumulate rate\n\t\tthis.rateCount += this.props.rate;\n\n\t\tlet count = Math.floor(this.rateCount);\n\n\t\t// add rate number of more particles\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tif (reusable.length) {\n\t\t\t\tlet particle = reusable.shift();\n\t\t\t\tparticle.reset(this.props);\n\t\t\t} else {\n\t\t\t\tif (this.particles.length >= this.props.quantity) return;\n\t\t\t\tlet particle = new Particle(this.props, this.mesh);\n\t\t\t\tthis.particles.push(particle);\n\t\t\t}\n\t\t\tthis.rateCount -= 1;\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorParticles.js?");

/***/ }),

/***/ "../public/js/BehaviorPhysics.js":
/*!***************************************!*\
  !*** ../public/js/BehaviorPhysics.js ***!
  \***************************************/
/*! exports provided: BehaviorPhysics, BehaviorPhysical */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorPhysics\", function() { return BehaviorPhysics; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorPhysical\", function() { return BehaviorPhysical; });\n\n\n///\n/// BehaviorPhysics\n///\n/// A physics capability - singleton\n///\n\nlet physicsInstance = 0;\n\nclass BehaviorPhysics {\n\n\t/// helper to get at instance\n\tstatic getInstance() {\n\t\tif (!physicsInstance) physicsInstance = new BehaviorPhysics();\n\t\treturn physicsInstance;\n\t}\n\n\t/// singleton constructor, can be called multiple times although it is slightly wasteful (a tiny object is created and thrown away)\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\n\t\t// a singleton\n\t\tif (physicsInstance) {\n\t\t\tconsole.error(\"Warning: Multiple instances of BehaviorPhysics - use .getInstance()\");\n\t\t\treturn physicsInstance;\n\t\t}\n\t\tphysicsInstance = this;\n\n\t\tAmmo();\n\n\t\tthis.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();\n\t\tthis.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);\n\t\tthis.overlappingPairCache = new Ammo.btDbvtBroadphase();\n\t\tthis.solver = new Ammo.btSequentialImpulseConstraintSolver();\n\t\tthis.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);\n\n\t\tthis.dynamicsWorld.setGravity(new Ammo.btVector3(0, -10, 0));\n\n\t\tthis.bodies = [];\n\t}\n\n\taddConstraint(constraint) {\n\t\tthis.dynamicsWorld.addConstraint(constraint);\n\t}\n\n\taddRigidBody(body) {\n\t\tthis.dynamicsWorld.addRigidBody(body);\n\t\tthis.bodies.push(body);\n\t}\n\n\ton_tick() {\n\t\tthis.dynamicsWorld.stepSimulation(1 / 60, 10);\n\t}\n\n\tdestroy() {\n\t\tAmmo.destroy(this.dynamicsWorld);\n\t\tAmmo.destroy(this.solver);\n\t\tAmmo.destroy(this.overlappingPairCache);\n\t\tAmmo.destroy(this.dispatcher);\n\t\tAmmo.destroy(this.collisionConfiguration);\n\t}\n\n}\n\n///\n/// BehaviorPhysical\n///\n/// A physics capability for meshes\n///\n///\n\nclass BehaviorPhysical {\n\tconstructor(props, blox) {\n\n\t\tif (!blox.mesh) {\n\t\t\t/// TODO right now there is a bit of a hack where it looks for a 'mesh' property on the parent - may be better to force specify hull?\n\t\t\tconsole.error(\"There has to be a mesh behavior in this object already\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (blox.physical) {\n\t\t\t/// TODO right now there is a bit of a hack where it looks for a 'mesh' property on the parent - may be better to force specify hull?\n\t\t\tconsole.error(\"Object already has a physical behavior\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.props = props;\n\n\t\t// Force properties to exist\n\t\tlet scale = blox.mesh.scale;\n\t\tlet position = blox.mesh.position;\n\t\tlet size = scale.length();\n\n\t\tlet mass = this.mass = props.mass || 0;\n\t\tlet transform = this.transform = 0;\n\n\t\tlet hull = \"sphere\";\n\t\tif (blox.mesh.geometry instanceof THREE.BoxBufferGeometry) hull = \"box\";\n\t\tif (blox.mesh.geometry instanceof THREE.SphereGeometry) hull = \"sphere\";\n\t\tlet shape = 0;\n\n\t\tswitch (hull) {\n\t\t\tcase \"sphere\":\n\t\t\t\tshape = this.shape = new Ammo.btSphereShape(size / 2);\n\t\t\t\ttransform = this.transform = new Ammo.btTransform();\n\t\t\t\ttransform.setIdentity();\n\t\t\t\ttransform.setOrigin(new Ammo.btVector3(position.x, position.y, position.z));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tshape = this.shape = new Ammo.btBoxShape(new Ammo.btVector3(scale.x / 2, scale.y / 2, scale.z / 2));\n\t\t\t\ttransform = this.transform = new Ammo.btTransform();\n\t\t\t\ttransform.setIdentity();\n\t\t\t\ttransform.setOrigin(new Ammo.btVector3(position.x, position.y, position.z));\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet localInertia = new Ammo.btVector3(0, 0, 0);\n\t\tif (mass) shape.calculateLocalInertia(mass, localInertia);\n\t\tlet myMotionState = new Ammo.btDefaultMotionState(transform);\n\t\tlet rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, shape, localInertia);\n\n\t\tlet body = this.body = new Ammo.btRigidBody(rbInfo);\n\t\tthis.trans = new Ammo.btTransform();\n\n\t\t// super bouncy for now\n\t\tthis.body.setRestitution(0.9);\n\n\t\t// disable deactivation for now\n\t\tthis.body.setActivationState(4);\n\t\tthis.body.activate();\n\n\t\tif (this.props.launch) {\n\t\t\tthis.body.applyCentralForce(new Ammo.btVector3(this.props.launch.x, this.props.launch.y, this.props.launch.z));\n\t\t\tthis.body.applyCentralImpulse(new Ammo.btVector3(this.props.launch.x, this.props.launch.y, this.props.launch.z));\n\t\t}\n\n\t\tBehaviorPhysics.getInstance().addRigidBody(this.body);\n\n\t\tif (props.joint) this.testJoint(props);\n\t}\n\n\t///\n\t/// hack test code\n\t///\n\n\ttestJoint(props) {\n\n\t\tlet bodies = BehaviorPhysics.getInstance().bodies;\n\n\t\tlet test1 = bodies[bodies.length - 2];\n\t\tlet test2 = bodies[bodies.length - 1];\n\n\t\tlet transforma = new Ammo.btTransform();\n\t\ttransforma.setIdentity();\n\t\t//transforma.setOrigin(new Ammo.btVector3(0, 10, 0))\n\n\t\tlet transformb = new Ammo.btTransform();\n\t\ttransformb.setIdentity();\n\t\t//transformb.setOrigin(new Ammo.btVector3(0, 0, 0))\n\n\t\tlet constraint = new Ammo.btSliderConstraint(test1, test2, transforma, transformb, true);\n\n\t\tconstraint.setLowerLinLimit(0);\n\t\tconstraint.setUpperLinLimit(2);\n\n\t\t// don't need to do this\n\t\t//\tconstraint.setLowerAngLimit(-1)\n\t\t//\tconstraint.setUpperAngLimit(-1)\n\n\t\t// motors are not supported\n\t\t//\tconstraint.setLinMotorVelocity( 1 )\n\t\t//\tconstraint.setMaxLinMotorForce( 0.0001 );\n\t\t//\tconstraint.setPoweredLinMotor( true );\n\n\t\t// try see if a persistent force will make it stay at limit\n\t\t//\tconstraint.setSoftnessLimLin( params.linear || 0 )\n\t\t//\tconstraint.setSoftnessLimAng( params.angular || 0 )\n\n\t\tBehaviorPhysics.getInstance().addConstraint(constraint);\n\t}\n\n\ton_tick(args) {\n\t\tlet blox = args.blox;\n\n\t\tif (!blox.mesh) return;\n\n\t\tif (this.props.force) {\n\t\t\t// test code remove - idea is to push the button back out constantly - TODO\n\t\t\t//this.body.applyCentralForce(new Ammo.btVector3(this.props.force.x,this.props.force.y,this.props.force.z))\n\t\t\tthis.body.applyCentralImpulse(new Ammo.btVector3(this.props.force.x, this.props.force.y, this.props.force.z));\n\t\t}\n\n\t\tlet ms = this.body.getMotionState();\n\t\tif (ms) {\n\t\t\tms.getWorldTransform(this.trans);\n\t\t\tvar p = this.trans.getOrigin();\n\t\t\tvar q = this.trans.getRotation();\n\t\t\tblox.mesh.position.set(p.x(), p.y(), p.z());\n\t\t\tblox.mesh.quaternion.set(q.x(), q.y(), q.z(), q.w());\n\t\t}\n\t}\n}\n\n/*\nfunction shootSphere () {\n    First, we need a ray from the camera.\n    Because we need a shooting position, and a shooting direction.\n  var vp = mat4.multiply([], projectionMatrix, viewMatrix)\n  var invVp = mat4.invert([], vp)\n\n  // get a single point on the camera ray.\n  var rayPoint = vec3.transformMat4([], [2.0 * mp[0] / canvas.width - 1.0, -2.0 * mp[1] / canvas.height + 1.0, 0.0], invVp)\n\n  // get the position of the camera.\n  var rayOrigin = vec3.transformMat4([], [0, 0, 0], mat4.invert([], viewMatrix))\n\n  var rayDir = vec3.normalize([], vec3.subtract([], rayPoint, rayOrigin))\n\n  // we release the ball a bit in front of the camera.\n  vec3.scaleAndAdd(rayOrigin, rayOrigin, rayDir, 4.4)\n\n    Next, create the sphere mesh\n  var mesh = primitiveSphere(1.0, {\n    segments: 16\n  })\n  var sphereMesh = new Mesh(mesh.cells, mesh.positions, mesh.normals)\n\n    Then, create the rigid body.\n  var mass = 1.0\n  var shape = new BtSphereShape(1)\n  shape.setMargin(0.05)\n  var motionState = new BtDefaultMotionState(new BtTransform(new BtQuaternion(0, 0, 0, 1), new BtVector3(rayOrigin[0], rayOrigin[1], rayOrigin[2])))\n\n  var localInertia = new BtVector3(0, 0, 0)\n  shape.calculateLocalInertia(mass, localInertia)\n\n  var ci = new BtRigidBodyConstructionInfo(mass, motionState, shape, localInertia)\n  var rigidBody = new BtRigidBody(ci)\n  physicsWorld.addRigidBody(rigidBody)\n\n    Now send the rigid body flying!\n  var POWER = 80.0\n  rigidBody.applyImpulse(new BtVector3(POWER * rayDir[0], POWER * rayDir[1], POWER * rayDir[2]), new BtVector3(rayOrigin[0], rayOrigin[1], rayOrigin[2]))\n\n  return {rigidBody: rigidBody, drawCall: sphereMesh, color: [1.0, 1.0, 1.0]}\n}\n\nvar transformTemp = new BtTransform()\n// extracts the model matrix from a rigid body.\nfunction getModelMatrix (rb) {\n  var ms = rb.getMotionState()\n\n  if (ms) {\n    ms.getWorldTransform(transformTemp)\n    var p = transformTemp.getOrigin()\n    var q = transformTemp.getRotation()\n\n    return mat4.fromRotationTranslation(\n      [], [q.x(), q.y(), q.z(), q.w()], [p.x(), p.y(), p.z()])\n  }\n}\n*/\n\n/*\n\nvarious kinds of primitives\n\nhttps://github.com/kripken/ammo.js/blox/master/examples/webgl_demo_terrain/index.html\n\n\n\t\t\t\tswitch ( objectType ) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t// Sphere\n\t\t\t\t\t\tvar radius = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.SphereGeometry( radius, 20, 20 ), createObjectMaterial() );\n\t\t\t\t\t\tshape = new Ammo.btSphereShape( radius );\n\t\t\t\t\t\tshape.setMargin( margin );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t// Box\n\t\t\t\t\t\tvar sx = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tvar sy = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tvar sz = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), createObjectMaterial() );\n\t\t\t\t\t\tshape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );\n\t\t\t\t\t\tshape.setMargin( margin );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\t// Cylinder\n\t\t\t\t\t\tvar radius = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tvar height = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.CylinderGeometry( radius, radius, height, 20, 1 ), createObjectMaterial() );\n\t\t\t\t\t\tshape = new Ammo.btCylinderShape( new Ammo.btVector3( radius, height * 0.5, radius ) );\n\t\t\t\t\t\tshape.setMargin( margin );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Cone\n\t\t\t\t\t\tvar radius = 1 + Math.random() * objectSize;\n\t\t\t\t\t\tvar height = 2 + Math.random() * objectSize;\n\t\t\t\t\t\tthreeObject = new THREE.Mesh( new THREE.CylinderGeometry( 0, radius, height, 20, 2 ), createObjectMaterial() );\n\t\t\t\t\t\tshape = new Ammo.btConeShape( radius, height );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n*/\n\n/*\n\ncannon\n\nthis.world = new CANNON.World();\nthis.world.defaultContactMaterial.contactEquationStiffness = 1e6;\nthis.world.defaultContactMaterial.contactEquationRegularizationTime = 3;\nthis.world.solver.iterations = 20;\nthis.world.gravity.set(this.gravity.x, this.gravity.y, this.gravity.z);\nthis.world.allowSleep = true;\nthis.world.broadphase = new CANNON.SAPBroadphase(this.world);\n\n\nOn bodies, I set:\nbody.allowSleep = true;\nbody.sleepSpeedLimit = 0.01;\nbody.sleepTimeLimit = 1.0;\n\nOn the material:\nmass: 100 (or about the mass of the object in kilograms)\nfriction: 0.1\nrestitution: 0.3 \n\n*/\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorPhysics.js?");

/***/ }),

/***/ "../public/js/BehaviorProton.js":
/*!**************************************!*\
  !*** ../public/js/BehaviorProton.js ***!
  \**************************************/
/*! exports provided: BehaviorProton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorProton\", function() { return BehaviorProton; });\n\nclass BehaviorProton {\n\n    constructor(args) {\n        let props = args.description;\n        let blox = args.blox;\n        this.props = props;\n        this.particles = [];\n        this.rateCount = 0;\n        this.parentMesh = blox._findByProperty(\"isObject3D\");\n        let scene = blox.parent.scene; // hack\n        if (!scene) console.error(\"no scene\");\n        this.parentMesh.material.visible = false;\n        this.initProton(this.parentMesh, scene);\n    }\n    on_tick(args) {\n        this.proton.update();\n    }\n\n    initProton(mesh, scene) {\n        let proton = this.proton = new Proton();\n        let emitter1 = this.emitter1 = this.createEmitter({\n            p: {\n                x: -100,\n                y: 0\n            },\n            Body: this.createMesh(\"sphere\")\n        });\n        let emitter2 = this.emitter2 = this.createEmitter({\n            p: {\n                x: 100,\n                y: 0\n            },\n            Body: this.createMesh(\"cube\")\n        });\n        proton.addEmitter(emitter1);\n        proton.addEmitter(emitter2);\n        proton.addRender(new Proton.MeshRender(scene));\n        Proton.Debug.drawEmitter(proton, scene, emitter1);\n        Proton.Debug.drawEmitter(proton, scene, emitter2);\n    }\n\n    createMesh(geo) {\n        if (geo == \"sphere\") {\n            var geometry = new THREE.SphereGeometry(10, 8, 8);\n            var material = new THREE.MeshLambertMaterial({\n                color: \"#ff0000\"\n            });\n        } else {\n            var geometry = new THREE.BoxGeometry(20, 20, 20);\n            var material = new THREE.MeshLambertMaterial({\n                color: \"#00ffcc\"\n            });\n        }\n        var mesh = new THREE.Mesh(geometry, material);\n        return mesh;\n    }\n\n    createEmitter(obj) {\n        var emitter = new Proton.Emitter();\n        emitter.rate = new Proton.Rate(new Proton.Span(5, 10), new Proton.Span(.1, .25));\n        emitter.addInitialize(new Proton.Mass(1));\n        emitter.addInitialize(new Proton.Radius(10));\n        emitter.addInitialize(new Proton.Life(2, 4));\n        emitter.addInitialize(new Proton.Body(obj.Body));\n        emitter.addInitialize(new Proton.Position(new Proton.BoxZone(100)));\n        emitter.addInitialize(new Proton.Velocity(200, new Proton.Vector3D(0, 1, 1), 30));\n        emitter.addBehaviour(new Proton.Rotate(\"random\", \"random\"));\n        emitter.addBehaviour(new Proton.Scale(1, 0.1));\n        //Gravity\n        emitter.addBehaviour(new Proton.Gravity(3));\n        emitter.p.x = obj.p.x;\n        emitter.p.y = obj.p.y;\n        emitter.emit();\n        return emitter;\n    }\n\n}\n\n/*\nsnow\n\n\n    function addProton() {\n        proton = new Proton();\n        emitter = new Proton.Emitter();\n        emitter.rate = new Proton.Rate(new Proton.Span(34, 48), new Proton.Span(.2, .5));\n        emitter.addInitialize(new Proton.Mass(1));\n        emitter.addInitialize(new Proton.Radius(new Proton.Span(10, 20)));\n        var position = new Proton.Position();\n        position.addZone(new Proton.BoxZone(2500, 10, 2500));\n        emitter.addInitialize(position);\n        emitter.addInitialize(new Proton.Life(5, 10));\n        emitter.addInitialize(new Proton.Body(createSnow()));\n        emitter.addInitialize(new Proton.Velocity(0, new Proton.Vector3D(0, -1, 0), 90));\n        emitter.addBehaviour(new Proton.RandomDrift(10, 1, 10, .05));\n        emitter.addBehaviour(new Proton.Rotate(\"random\", \"random\"));\n        emitter.addBehaviour(new Proton.Gravity(2));\n        var sceenZone = new Proton.ScreenZone(camera, renderer, 20, \"234\");\n        emitter.addBehaviour(new Proton.CrossZone(sceenZone, \"dead\"));\n        emitter.p.x = 0;\n        emitter.p.y = 800;\n        emitter.emit();\n        proton.addEmitter(emitter);\n        proton.addRender(new Proton.SpriteRender(scene));\n        //Proton.Debug.drawZone(proton,scene,new Proton.BoxZone(800, 10, 800));\n    }\n    function createSnow() {\n        var map = new THREE.TextureLoader().load(\"./img/snow.png\");\n        var material = new THREE.SpriteMaterial({\n            map: map,\n            transparent: true,\n            opacity: .5,\n            color: 0xffffff\n        });\n        return new THREE.Sprite(material);\n    }\n\n    */\n\n/*\n  function addProton() {\n    proton = new Proton();\n    proton.addEmitter(createEmitter());\n    proton.addRender(new Proton.SpriteRender(scene));\n}\nfunction createSprite() {\n    var map = new THREE.TextureLoader().load(\"./img/dot.png\");\n    var material = new THREE.SpriteMaterial({\n        map: map,\n        color: 0xff0000,\n        blending: THREE.AdditiveBlending,\n        fog: true\n    });\n    return new THREE.Sprite(material);\n}\nfunction createEmitter() {\n    emitter = new Proton.Emitter();\n    emitter.rate = new Proton.Rate(new Proton.Span(10, 15), new Proton.Span(.05, .1));\n    emitter.addInitialize(new Proton.Body(createSprite()));\n    emitter.addInitialize(new Proton.Mass(1));\n    emitter.addInitialize(new Proton.Life(1, 3));\n    emitter.addInitialize(new Proton.Position(new Proton.SphereZone(20)));\n    emitter.addInitialize(new Proton.V(new Proton.Span(500, 800), new Proton.Vector3D(0, 1, 0), 30));\n    emitter.addBehaviour(new Proton.RandomDrift(10, 10, 10, .05));\n    //emitter.addBehaviour(new Proton.Alpha(1, 0.1));\n    emitter.addBehaviour(new Proton.Scale(new Proton.Span(2, 3.5), 0));\n    emitter.addBehaviour(new Proton.G(6));\n    emitter.addBehaviour(new Proton.Color('#FF0026', ['#ffff00', '#ffff11'], Infinity, Proton.easeOutSine));\n    emitter.p.x = 0;\n    emitter.p.y = -150;\n    emitter.emit();\n    return emitter;\n}\n*/\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorProton.js?");

/***/ }),

/***/ "../public/js/BehaviorRenderer.js":
/*!****************************************!*\
  !*** ../public/js/BehaviorRenderer.js ***!
  \****************************************/
/*! exports provided: BehaviorRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorRenderer\", function() { return BehaviorRenderer; });\n\n\nclass BehaviorRenderer extends THREE.WebGLRenderer {\n\tconstructor(args) {\n\t\tlet props = args.description || {};\n\t\tlet blox = args.blox;\n\t\tsuper({ antialias: true, alpha: XRSupport.supportsARKit() });\n\t\tthis.setSize(window.innerWidth, window.innerHeight);\n\t\tthis.props = props;\n\t\tthis.blox = blox;\n\t\tthis.clock = new THREE.Clock();\n\t\tthis.scene = 0;\n\t\tthis.camera = 0;\n\t\tthis.pov = 0;\n\n\t\t// supports VR? HACK\n\t\tlet usevr = window.supportsVR ? true : false;\n\n\t\tthis.PASSTHROUGH = XRSupport.supportsARKit();\n\t\tif (!this.PASSTHROUGH && !usevr) {\n\t\t\tdocument.body.appendChild(this.domElement);\n\t\t\tthis.setAnimationLoop(this.render3.bind(this));\n\t\t} else {\n\t\t\tthis.xr = new XRSupport({\n\t\t\t\trenderer: this,\n\t\t\t\tupdatePOV: this.updatePOV.bind(this),\n\t\t\t\tupdateCamera: this.updateCamera.bind(this),\n\t\t\t\tupdateScene: this.updateScene.bind(this),\n\t\t\t\trenderScene: this.renderScene.bind(this),\n\t\t\t\tcreateVirtualReality: usevr ? true : false,\n\t\t\t\tshouldStartPresenting: true,\n\t\t\t\tuseComputervision: false,\n\t\t\t\tworldSensing: usevr ? false : true,\n\t\t\t\talignEUS: usevr ? false : true\n\t\t\t});\n\t\t}\n\t}\n\n\tupdatePOV(viewMatrix) {\n\t\tif (!this.pov) return;\n\t\tthis.pov.matrixAutoUpdate = false;\n\t\tthis.pov.matrix.fromArray(viewMatrix);\n\t\tthis.pov.updateMatrixWorld();\n\t}\n\n\tupdateCamera(projectionMatrix) {\n\t\tif (!this.camera) return;\n\t\tthis.camera.projectionMatrix.fromArray(projectionMatrix);\n\t}\n\n\tupdateScene() {\n\t\tif (!this.scene || !this.camera) return;\n\t\tthis.blox.on_event({ blox: this.blox, name: \"on_tick\", interval: this.clock.getElapsedTime() });\n\t}\n\n\trenderScene() {\n\t\tif (!this.scene || !this.camera) return;\n\t\tthis.render(this.scene, this.camera);\n\t}\n\n\trender3() {\n\t\tif (!this.scene || !this.camera) return;\n\t\tthis.updateScene();\n\t\tthis.renderScene();\n\t}\n\n\treset(scene, camera, pov) {\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\t\tthis.pov = camera;\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorRenderer.js?");

/***/ }),

/***/ "../public/js/BehaviorSky.js":
/*!***********************************!*\
  !*** ../public/js/BehaviorSky.js ***!
  \***********************************/
/*! exports provided: BehaviorSky */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorSky\", function() { return BehaviorSky; });\nclass BehaviorSky extends THREE.Mesh {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tlet sky_vertex = `\n\t\t\tvarying vec2 vUV;\n\t\t\tvoid main() {  \n\t\t\t  vUV = uv;\n\t\t\t  vec4 pos = vec4(position, 1.0);\n\t\t\t  gl_Position = projectionMatrix * modelViewMatrix * pos;\n\t\t\t}\n\t\t\t`;\n\t\tlet sky_fragment = `\n\t\t\tuniform sampler2D texture;  \n\t\t\tvarying vec2 vUV;\n\n\t\t\tvoid main() {  \n\t\t\t  vec4 sample = texture2D(texture, vUV);\n\t\t\t  gl_FragColor = vec4(sample.xyz, sample.w);\n\t\t\t}\n\t\t\t`;\n\t\tvar geometry = new THREE.SphereGeometry(-500, 60, 40);\n\t\tvar uniforms = {\n\t\t\ttexture: { type: 't', value: THREE.ImageUtils.loadTexture(props.art) }\n\t\t};\n\t\tvar material = new THREE.ShaderMaterial({\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: sky_vertex,\n\t\t\tfragmentShader: sky_fragment\n\t\t});\n\t\tlet skyBox = super(geometry, material);\n\t\t// skyBox.scale.set(-1, 1, 1) - flipped the above sphere instead\n\t\tskyBox.renderDepth = 1000.0;\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorSky.js?");

/***/ }),

/***/ "../public/js/BehaviorText.js":
/*!************************************!*\
  !*** ../public/js/BehaviorText.js ***!
  \************************************/
/*! exports provided: BehaviorText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorText\", function() { return BehaviorText; });\n/* harmony import */ var _BehaviorMesh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BehaviorMesh.js */ \"../public/js/BehaviorMesh.js\");\n\n\n\n///\n/// Text\n/// - could center TODO\n/// - could offer word wrap TODO\n/// - could combine 2d composited text layouts with this\n\nclass BehaviorText extends _BehaviorMesh_js__WEBPACK_IMPORTED_MODULE_0__[\"BehaviorMesh\"] {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tprops.art = \"sphere\"; // temporary\n\t\tsuper(props, blox);\n\t\tthis.props = props;\n\t\tvar loader = new THREE.FontLoader();\n\t\tloader.load('fonts/helvetiker_bold.typeface.json', this.attachText.bind(this));\n\t}\n\n\tattachText(font) {\n\t\tlet props = this.props;\n\t\tlet text = props && props.say ? props.say : \"nothing\";\n\t\tlet size = props && props.size ? props.size : 1;\n\t\tlet height = props && props.height ? props.height : 1;\n\t\tlet color = props && props.color ? props.color : 0xFF00FF;\n\t\tvar geometry = new THREE.TextGeometry(text, {\n\t\t\tfont: font,\n\t\t\tsize: size,\n\t\t\theight: height\n\t\t});\n\t\tif (this.geometry) this.geometry.dispose();\n\t\tthis.geometry = geometry;\n\t}\n\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorText.js?");

/***/ }),

/***/ "../public/js/BehaviorTextPanel.js":
/*!*****************************************!*\
  !*** ../public/js/BehaviorTextPanel.js ***!
  \*****************************************/
/*! exports provided: BehaviorTextPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorTextPanel\", function() { return BehaviorTextPanel; });\n/* harmony import */ var _BehaviorMesh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BehaviorMesh.js */ \"../public/js/BehaviorMesh.js\");\n\n\n\nclass BehaviorTextPanel extends _BehaviorMesh_js__WEBPACK_IMPORTED_MODULE_0__[\"BehaviorMesh\"] {\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\t\tprops.art = \"sphere\"; // temporary\n\t\tsuper(props, blox);\n\t\tthis.props = props;\n\n\t\tlet material = this.makeMaterial(props.say || \"hello\");\n\t\tlet geometry = this.makeGeometry(1, 1);\n\n\t\tif (this.material) this.material.dispose();\n\t\tthis.material = material;\n\n\t\tif (this.geometry) this.geometry.dispose();\n\t\tthis.geometry = geometry;\n\t}\n\n\tmakeGeometry(w, h) {\n\t\treturn new THREE.PlaneGeometry(w, h, 10, 10);\n\t}\n\n\tmakeMaterial(prettywords) {\n\n\t\t// Add a nice round rectangle feature\n\n\t\tCanvasRenderingContext2D.prototype.roundRect = function (sx, sy, ex, ey, r) {\n\t\t\tvar r2d = Math.PI / 180;\n\t\t\tif (ex - sx - 2 * r < 0) {\n\t\t\t\tr = (ex - sx) / 2;\n\t\t\t} //ensure that the radius isn't too large for x\n\t\t\tif (ey - sy - 2 * r < 0) {\n\t\t\t\tr = (ey - sy) / 2;\n\t\t\t} //ensure that the radius isn't too large for y\n\t\t\tthis.beginPath();\n\t\t\tthis.moveTo(sx + r, sy);\n\t\t\tthis.lineTo(ex - r, sy);\n\t\t\tthis.arc(ex - r, sy + r, r, r2d * 270, r2d * 360, false);\n\t\t\tthis.lineTo(ex, ey - r);\n\t\t\tthis.arc(ex - r, ey - r, r, r2d * 0, r2d * 90, false);\n\t\t\tthis.lineTo(sx + r, ey);\n\t\t\tthis.arc(sx + r, ey - r, r, r2d * 90, r2d * 180, false);\n\t\t\tthis.lineTo(sx, sy + r);\n\t\t\tthis.arc(sx + r, sy + r, r, r2d * 180, r2d * 270, false);\n\t\t\tthis.closePath();\n\t\t};\n\n\t\t// a convenient bubble drawer\n\n\t\tfunction drawBubble(ctx, x, y, w, h, radius) {\n\t\t\tvar r = x + w;\n\t\t\tvar b = y + h;\n\t\t\tctx.beginPath();\n\t\t\tctx.strokeStyle = \"#30A030\";\n\t\t\tctx.lineWidth = \"6\";\n\t\t\tctx.moveTo(x + radius, y);\n\t\t\t//ctx.lineTo(x+radius/2, y-10);\n\t\t\t//ctx.lineTo(x+radius * 2, y);\n\t\t\tctx.lineTo(r - radius, y);\n\t\t\tctx.quadraticCurveTo(r, y, r, y + radius);\n\t\t\tctx.lineTo(r, y + h - radius);\n\t\t\tctx.quadraticCurveTo(r, b, r - radius, b);\n\t\t\tctx.lineTo(x + radius, b);\n\t\t\tctx.quadraticCurveTo(x, b, x, b - radius);\n\t\t\tctx.lineTo(x, y + radius);\n\t\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\t\tctx.stroke();\n\t\t}\n\n\t\t// a handy dandy text wrapper\n\t\t// TODO support line breaks\n\n\t\tfunction wrapText(context, text, x, y, maxWidth, lineHeight) {\n\t\t\tvar words = text.split(' ');\n\t\t\tvar line = '';\n\t\t\tfor (var n = 0; n < words.length; n++) {\n\t\t\t\tvar testLine = line + words[n] + ' ';\n\t\t\t\tvar metrics = context.measureText(testLine);\n\t\t\t\tvar testWidth = metrics.width;\n\t\t\t\tif (testWidth > maxWidth && n > 0) {\n\t\t\t\t\tcontext.fillText(line, x, y);\n\t\t\t\t\tline = words[n] + ' ';\n\t\t\t\t\ty += lineHeight;\n\t\t\t\t} else {\n\t\t\t\t\tline = testLine;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontext.fillText(line, x, y);\n\t\t}\n\n\t\t// hack -TODO caller should be able to set these\n\t\tlet fsize = 60;\n\t\tlet w = 1024;\n\t\tlet h = 1024;\n\n\t\t// a scratch canvas\n\t\t// TODO caller needs to be able to set various params here\n\n\t\tlet scratch = document.createElement(\"canvas\");\n\t\tscratch.width = w;\n\t\tscratch.height = h;\n\t\tlet context = scratch.getContext(\"2d\");\n\t\t//context.clearRect(0,0,w,h);\n\t\tcontext.font = fsize + \"pt Arial\";\n\t\t//context.textAlign = \"center\"\n\t\t//context.fillStyle = \"#000000\"\n\t\t//context.fillRect(0, 0, w, h)\n\t\tcontext.fillStyle = \"#cc00cc\";\n\t\tcontext.strokeStyle = \"#cc00cc\";\n\t\t//context.fillText(args, scratch.width / 2, scratch.height / 2)\n\n\t\t//\tcontext.roundRect(0,0,600,600,10).stroke(); //or .fill() for a filled rect\n\t\t//_cxt.roundRect(35,10,260,120,20);\n\t\t//_cxt.strokeStyle = \"#000\";\n\t\t//_cxt.stroke();\n\n\t\tdrawBubble(context, 10, 10, w - 20, h - 20, 5);\n\n\t\twrapText(context, prettywords, fsize, fsize * 1.5 + 2, w - fsize * 2, fsize + 2);\n\n\t\tlet texture = new THREE.Texture(scratch);\n\t\ttexture.needsUpdate = true;\n\t\tlet material = new THREE.MeshBasicMaterial({ map: texture });\n\n\t\treturn material;\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorTextPanel.js?");

/***/ }),

/***/ "../public/js/BehaviorWalk.js":
/*!************************************!*\
  !*** ../public/js/BehaviorWalk.js ***!
  \************************************/
/*! exports provided: BehaviorWalk */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorWalk\", function() { return BehaviorWalk; });\n\n///\n/// Associates keyboard control with a mesh\n///\n/// Typically I expect the user to add a camera nearby\n///\n\nclass BehaviorWalk {\n\n\tconstructor(args) {\n\t\tlet props = args.description;\n\t\tlet blox = args.blox;\n\n\t\tthis.parentBehavior = blox.query({ property: \"isObject3D\" });\n\t\tif (!this.parentBehavior) {\n\t\t\tconsole.error(\"There needs to be some mesh associated with this behavior\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.camera = blox.query({ property: \"isPerspectiveCamera\" });\n\t\tif (!this.camera) {\n\t\t\tconsole.error(\"No camera found\");\n\t\t}\n\n\t\tthis.props = props;\n\t\tthis.blox = blox;\n\t\tthis.forward = new THREE.Vector3(0, 0, 1);\n\t\tthis.backward = new THREE.Vector3(0, 0, -1);\n\t\tthis.left = new THREE.Euler(0, 10 * Math.PI / 180.0, 0);\n\t\tthis.right = new THREE.Euler(0, -10 * Math.PI / 180.0, 0);\n\t\tdocument.addEventListener(\"keydown\", this.onKeyDown.bind(this), false);\n\t}\n\n\tonKeyDown(event) {\n\t\tlet blox = this.blox;\n\t\tif (!blox || !blox.intent) {\n\t\t\tconsole.error(\"Needs a mesh\");\n\t\t\treturn;\n\t\t}\n\t\tlet mesh = this.parentBehavior;\n\t\tswitch (event.key) {\n\t\t\tcase 'w':\n\t\t\t\t// up\n\t\t\t\tblox.intent.on_impulse({ linear: this.forward, angular: 0 });\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\t// down\n\t\t\t\tblox.intent.on_impulse({ linear: this.backward, angular: 0 });\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\t// left\n\t\t\t\tblox.intent.on_impulse({ linear: 0, angular: this.left });\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\t// right\n\t\t\t\tblox.intent.on_impulse({ linear: 0, angular: this.right });\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\t// space\n\t\t\t\tblox.intent.on_reset({});\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\ton_tick(args) {\n\n\t\tif (!this.camera) return;\n\n\t\tlet xrmode = typeof window.webkit !== 'undefined';\n\n\t\t// TODO TESTING XR - IMPROVE\n\t\t// if in vr mode then move camera to us\n\t\tif (!xrmode) {\n\t\t\tlet mesh = this.parentBehavior;\n\t\t\t//\t\t\tthis.material.visible = false\n\t\t\t//\t\t\tthis.visible = false\n\t\t\t// find a position behind the object\n\t\t\tlet v = new THREE.Vector3(0, 3, -10);\n\t\t\tv.applyMatrix4(mesh.matrixWorld);\n\t\t\tthis.camera.position.set(v.x, v.y, v.z);\n\t\t\t// look at the target\n\t\t\tthis.camera.lookAt(mesh.position);\n\t\t} else {\n\t\t\t// move this to the camera TODO TBD\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/BehaviorWalk.js?");

/***/ }),

/***/ "../public/js/Blox.js":
/*!****************************!*\
  !*** ../public/js/Blox.js ***!
  \****************************/
/*! exports provided: BehaviorGroup, Blox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BehaviorGroup\", function() { return BehaviorGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Blox\", function() { return Blox; });\n/* harmony import */ var _lib_importModule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/importModule.js */ \"../public/lib/importModule.js\");\n/* harmony import */ var _BehaviorRenderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BehaviorRenderer.js */ \"../public/js/BehaviorRenderer.js\");\n/* harmony import */ var _BehaviorCamera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BehaviorCamera.js */ \"../public/js/BehaviorCamera.js\");\n/* harmony import */ var _BehaviorLight_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BehaviorLight.js */ \"../public/js/BehaviorLight.js\");\n/* harmony import */ var _BehaviorMesh_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BehaviorMesh.js */ \"../public/js/BehaviorMesh.js\");\n/* harmony import */ var _BehaviorSky_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BehaviorSky.js */ \"../public/js/BehaviorSky.js\");\n/* harmony import */ var _BehaviorHeart_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BehaviorHeart.js */ \"../public/js/BehaviorHeart.js\");\n/* harmony import */ var _BehaviorText_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BehaviorText.js */ \"../public/js/BehaviorText.js\");\n/* harmony import */ var _BehaviorTextPanel_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BehaviorTextPanel.js */ \"../public/js/BehaviorTextPanel.js\");\n/* harmony import */ var _BehaviorIntent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./BehaviorIntent.js */ \"../public/js/BehaviorIntent.js\");\n/* harmony import */ var _BehaviorPhysics_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./BehaviorPhysics.js */ \"../public/js/BehaviorPhysics.js\");\n/* harmony import */ var _BehaviorCollide_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./BehaviorCollide.js */ \"../public/js/BehaviorCollide.js\");\n/* harmony import */ var _BehaviorOrbit_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./BehaviorOrbit.js */ \"../public/js/BehaviorOrbit.js\");\n/* harmony import */ var _BehaviorWalk_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./BehaviorWalk.js */ \"../public/js/BehaviorWalk.js\");\n/* harmony import */ var _BehaviorBounce_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./BehaviorBounce.js */ \"../public/js/BehaviorBounce.js\");\n/* harmony import */ var _BehaviorParticles_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./BehaviorParticles.js */ \"../public/js/BehaviorParticles.js\");\n/* harmony import */ var _BehaviorProton_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./BehaviorProton.js */ \"../public/js/BehaviorProton.js\");\n/* harmony import */ var _BehaviorEmitter_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./BehaviorEmitter.js */ \"../public/js/BehaviorEmitter.js\");\n// dynamic import support for firefox\n\n\n// Basic\n\n//import {BehaviorScene} from './BehaviorScene.js' // blox-hack -- use custom BehaviorScene instead via expose-behaviors.js\n\n\n\n\n// Some objects\n\n\n\n\n\n// Motion and physics, some of this may merge together\n\n\n\n\n// Motion models for player\n // TODO this one really needs to be rewritten\n\n\n// Some other behaviors\n\n\n\n\n\n// Intents - which are fancy behaviors - may roll back into Mesh itself\n\n// BehaviorAudio TBD\n\n//\n// This is a list of blox in a single flat namespace\n// TODO at some point refine this to support returning all the blox with the same name\n// Also support indexing by other properties for fast lookup, basically be a lightweight database\n//\n\nlet UUID = 0;\nlet global_blox_namespace = {};\n\n///\n/// BehaviorGroup\n///\n/// Manages children related to a blox\n///\n\nclass BehaviorGroup {\n\n\t///\n\t/// props = a json ARRAY describing a set of children\n\t/// blox = the current scope as is normally passed to all behaviors on construction\n\t///\n\n\tconstructor(args) {\n\t\tlet description = args.description;\n\t\tlet blox = args.blox;\n\t\tif (!blox) {\n\t\t\tconsole.error(\"Error: must have a parent blox\");\n\t\t\treturn;\n\t\t}\n\t\t// hack; normally these fields are set after but I set it early so that children can rely on group.blox.query()\n\t\tthis.blox = blox;\n\t\tblox.group = blox.behaviors.group = this;\n\t\t// this behavior manages a set of children - set that up\n\t\tthis.children = [];\n\t\t// load each one from the property definition and save it\n\t\tthis.on_reset(args);\n\t}\n\n\t///\n\t/// Pass a bunch of children\n\t///\n\ton_reset(args) {\n\t\tlet description = args.description; // TODO fails to deal with appending\n\t\tif (!description) return;\n\t\tif (description.constructor != Array) {\n\t\t\t// TODO later support loading children off disk\n\t\t\tconsole.error(\"Error: args must be an array\");\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < description.length; i++) {\n\t\t\tthis.push(description[i]);\n\t\t}\n\t}\n\n\t///\n\t/// Manufacture a new blox from a description\n\t///\n\t/// description = a json HASH describing a set of behaviors OR a string indicating a document to load\n\t///\n\n\tpush(description) {\n\t\tlet child = new Blox({ description: description, parent: this.blox });\n\t\tthis.children.push(child);\n\t\tconsole.log(\"Group added a child \" + child.name);\n\t\treturn child;\n\t}\n\n\t///\n\t/// Forward events to child blox\n\t///\n\n\ton_event(args) {\n\t\tthis.children.forEach(child => {\n\t\t\t// set the blox to current scope always\n\t\t\targs.blox = child;\n\t\t\tchild.on_event(args);\n\t\t});\n\t}\n\n}\n\n///\n/// Load - is reserved but I have to catch this by hand below because of problems with async/await\n///\n\nclass BehaviorLoad {}\n\n///\n/// Functions - Event Chain Behavior\n///\n/// Basically a blox might have some naked functions that a user defined such as on_tick(e) - I want to stash them here.\n/// I prefer it if anything a user makes is scoped as a method on a child behavior\n/// In that way the user function is consistently getting parent via reference - ie on_tick(e) { this.blox.do_something() }\n/// And now any user land function can recover scope by looking at this.blox rather than having it passed in the event.\n///\n\nclass BehaviorFunctions {\n\n\tconstructor(args) {\n\t\tthis.blox = args.blox;\n\t\tthis.chains = {};\n\t\t// I'm just going to take over this ability completely and manage it here\n\t\tthis.blox.on_event = this.on_event.bind(this);\n\t}\n\n\t///\n\t/// this entire method gets injected into the parent blox\n\t///\n\t/// given an event pass it to three customers\n\t//\t\t1) any matching naked functions that were scavenged during loading the blox document\n\t///\t\t2) any behaviors that specifically implement the event by name\n\t///\t\t3) any children blox that specifically implement the event by name\n\t///\n\t/// the construction logic already found those functions and stashed them here in 'chains'\n\t///\n\n\ton_event(args) {\n\t\t// set the blox to current scope regardless of what it was\n\t\targs.blox = this.blox;\n\n\t\tif (args.name != \"on_tick\") if (this.debug) console.log(\"functions:: propagating \" + args.name + \" from \" + this.blox.name);\n\n\t\t// look for specifically named events in local scope and call them\n\t\tthis._on_specific_named_event(args.name, args);\n\n\t\t// also, pass any specialized events to any listeners generic on_event catch all\n\t\tif (args.name == \"on_event\") return;\n\t\tthis._on_specific_named_event(\"on_event\", args);\n\t}\n\n\t_on_specific_named_event(name, args) {\n\t\t// set the blox to current scope regardless of what it was\n\t\targs.blox = this.blox;\n\t\t// find the chain\n\t\tlet chain = this.chains[name];\n\t\tif (chain) {\n\t\t\tfor (let i = 0; i < chain.length; i++) {\n\t\t\t\tlet myhandle = chain[i];\n\t\t\t\tmyhandle(args); // TODO arguably 0 could mean stop propagation OR I could make users make their own chains?\n\t\t\t}\n\t\t}\n\t}\n\n\tpush(args) {\n\t\tlet label = args.label;\n\t\tlet handler = args.handler;\n\t\tlet owner = args.owner;\n\n\t\t// make a fresh chain system if needed\n\t\tlet chain = this.chains[label];\n\t\tif (!chain) {\n\t\t\t// make a fresh chain\n\t\t\tchain = this.chains[label] = [];\n\t\t\t// TEST: not working well... promote chains directly up to the blox scope so they are visible to userland\n\t\t\tif (false) {}\n\t\t}\n\n\t\t// add the users function to the chain\n\t\tchain.push(handler.bind(owner));\n\t\tif (this.debug) console.log(\"functions:: added \" + label + \" to \" + this.blox.name);\n\t}\n}\n\n///\n/// A blox is a flattened namespace that holds 1) children blox, 2) behaviors and 3) functions or events\n/// It's basically an ECS pattern and it doesn't know anything about the use case.\n///\n/// A blox can be inhaled from a text document\n/// Namespace collisions *are* possible and naming conventions are used to mitigate them.\n///\n/// Every blox has\n///\t\t- a name, which does not need to be unique but I haven't thought much about duplicate names yet\n///\t\t- a parent, which may be 0\n///\t\t- a description which is used to produce the blox from scratch\n///\t\t- a set of behaviors... this is the main job of this class\n///\t\t- a behavior that is a group of children blox (this could be optional but for now I hard-code it)\n///\t\t- a behavior that is a group of function callbacks for event support (also hard coded)\n///\n/// Most behaviors are generic, but I make a couple for myself that are built-in effectively\n///\t\t- BehaviorLoad -> let's me work around an async issue and lets me implement packages\n///\t\t- BehaviorGroup -> manages children\n///\t\t- BehaviorFunctions -> manages events and callbacks\n///\n///\tThe document loader has a series of steps\n///\t\t- if the child property is a behavior, then it asserts the behavior exists once only\n///\t\t- if the child property is a child blox (it can tell these apart) it adds it to its own group\n///\t\t- if the child property is a naked function it adds it to its own functions\n///\n\nclass Blox {\n\n\t/// accept a hash or naked string\n\t///\n\t/// description = a JSON hash of behaviors OR a string of a filename to load\n\t/// parent = a parent blox if any\n\n\tconstructor(args, parent = 0) {\n\n\t\t// there's a bit of support here for passing either a hash (in memory) or just a string (to load a hash off disk)\n\t\tif (typeof args === \"string\") {\n\t\t\tthis.parent = parent;\n\t\t\tthis.description = args;\n\t\t} else {\n\t\t\tthis.parent = args.parent || parent;\n\t\t\tthis.description = args.description || {};\n\t\t}\n\n\t\t// grant a default name that can be rewritten during construction\n\t\tthis.name = \"blox\" + UUID++;\n\n\t\t// all behaviors here (arguably this could also be implemented as sub behavior but simplest this way)\n\t\tthis.behaviors = {};\n\n\t\t// all functions here (seems to make sense to organize these as a kind of sub behavior)\n\t\tthis.functions = new BehaviorFunctions({ blox: this });\n\t\tthis.functions.blox = this;\n\n\t\t// don't do it this way because i don't want to propagate on_event to myself\n\t\t// this.add({label:\"functions\"})\n\n\t\t// add children powers now - convenient to hardcode this - but see below for a nicer way\n\t\t// this.behaviors.group = new BehaviorGroup({blox:this})\n\t\t// this.behaviors.group.blox = this\n\t\t// this.functions.push({label:\"on_event\",handler:this.behaviors.group.on_event,owner:this.behaviors.group})\n\n\t\t// might as well use the local machinery to do the above work\n\t\tthis.add({ label: \"group\" });\n\n\t\t// inject properties - a blox generally consists of a bucket of behaviors, go ahead and populate this blox\n\t\tthis.on_behaviors({ description: this.description, parent: this.parent });\n\t}\n\n\t///\n\t/// on_event will get over-written by this.functions logic - see BehaviorFunctions\n\t///\n\n\ton_event(args) {}\n\n\t///\n\t/// Fill a blox with behaviors\n\t/// TODO remove async when I can remove loadModule() - it seriously makes this all harder\n\t///\n\n\tasync on_behaviors(args) {\n\n\t\tlet parent = args.parent; // TODO - if the parent changes then what?\n\t\tlet behaviors = args.description; // TODO - I should probably append the description\n\n\t\t// deal with a file off disk\n\t\tif (typeof behaviors == 'string') {\n\t\t\tlet module = await Object(_lib_importModule_js__WEBPACK_IMPORTED_MODULE_0__[\"importModule\"])(behaviors);\n\t\t\tif (!module) {\n\t\t\t\tconsole.error(\"Cannot load module\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet keys = Object.keys(module);\n\t\t\tif (!keys.length) {\n\t\t\t\tconsole.error(\"Blox:: module has no export\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbehaviors = module[keys[0]]; // rewrite\n\t\t}\n\n\t\t// any work to do?\n\t\tif (!behaviors) {\n\t\t\treturn;\n\t\t}\n\n\t\t// is possibly a collection?\n\t\tif (behaviors.constructor != Object) {\n\t\t\tconsole.error(\"Blox behaviors need to be a hash\");\n\t\t\treturn;\n\t\t}\n\n\t\t// peek ahead at 'load' which is a reserved behavior right now due to annoying async issues TODO\n\t\tif (behaviors.load) {\n\t\t\tlet module = await Object(_lib_importModule_js__WEBPACK_IMPORTED_MODULE_0__[\"importModule\"])(behaviors.load);\n\t\t\tif (module) {\n\t\t\t\tlet keys = Object.keys(module);\n\t\t\t\tif (keys.length && module[keys[0]]) {\n\t\t\t\t\tlet behaviors_package = module[keys[0]];\n\t\t\t\t\tObject.entries(behaviors_package).forEach(([label, description]) => {\n\t\t\t\t\t\tthis.add({ label: label, description: description });\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete behaviors.load;\n\t\t}\n\n\t\t// add the normal behaviors\n\t\tObject.entries(behaviors).forEach(([label, description]) => {\n\t\t\tthis.add({ label: label, description: description });\n\t\t});\n\n\t\t// notify children of this blox that this blox is itself ready - TODO maybe not needed?\n\t\tthis.on_event({ name: \"on_loaded\", blox: this, loaded: this });\n\n\t\t// notify everybody globally that this blox is loaded\n\t\tif (this.parent) {\n\t\t\tthis.parent.on_event({ name: \"on_blox_added\", child: this });\n\t\t}\n\t}\n\n\tadd(args) {\n\n\t\tlet label = args.label;\n\t\tlet description = args.description;\n\t\tlet blox = this;\n\n\t\t// ===========================================================\n\t\t// ATTACH NAME 'name' is a reserved attribute\n\t\t// Save reference to this object in a global database\n\t\tif (label == \"name\") {\n\t\t\tif (typeof description !== \"string\") {\n\t\t\t\tconsole.error(\"A blox name must be a string and cannot be a child behavior!\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.name = description;\n\t\t\tglobal_blox_namespace[this.name] = this;\n\t\t\treturn;\n\t\t}\n\n\t\t// ============================================================\n\t\t// ATTACH PARENT - parent is reserved - checking and reporting this explicitly although below would catch it as well\n\t\tif (label == \"parent\") {\n\t\t\tconsole.error(\"A blox may not have a behavior called parent - this is a reserved term\");\n\t\t\treturn;\n\t\t}\n\n\t\t// ===================================================================\n\t\t// ATTACH NAKED FUNCTION\n\t\t// if the details are a function then remember it as well\n\t\tif (typeof description === \"function\") {\n\t\t\tthis.functions.push({ label: label, handler: description, owner: this.functions });\n\t\t\treturn;\n\t\t}\n\n\t\t// =====================================================================\n\t\t// ATTACH BEHAVIOR OR LITERAL\n\t\t// The name of the behavior to load\n\t\tlet className = \"Behavior\" + label.charAt(0).toUpperCase() + label.slice(1);\n\t\tlet classRef = 0;\n\t\tlet classInst = 0;\n\t\tlet isNew = true;\n\n\t\t// TEST flatten namespaces where behaviors are visible directly on the blox for userland\n\t\t// Does the 'behavior' that you want to create already exist as a property of some kind (a behavior, function etc?)\n\t\tfor (let count = 0;; count++) {\n\t\t\tlet previous = blox[label];\n\t\t\tif (!previous) break;\n\t\t\tif (typeof previous !== \"object\") {\n\t\t\t\tconsole.error(\"Error: your behavior collides with something already present : \" + label);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (previous.constructor.name == className) {\n\t\t\t\t// looks like you're trying to modify an existing behavior - this would be fine if you loaded a package\n\t\t\t\tconsole.log(\"editing \" + className);\n\t\t\t\tclassInst = previous;\n\t\t\t\tisNew = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Try find a class constructor for what appears to be a behavior\n\t\tif (!classInst) {\n\t\t\ttry {\n\t\t\t\tclassRef = eval(className);\n\t\t\t} catch (e) {\n\t\t\t\tclassRef = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Populate the child behavior with the passed description\n\t\tif (classRef || classInst) {\n\n\t\t\t// advise that the behavior will exist soon\n\t\t\tblox.on_event({ name: \"on_behavior_will_add\", description: description, blox: blox });\n\n\t\t\t// Instance the behavior if need be\n\t\t\tif (!classInst) {\n\t\t\t\ttry {\n\t\t\t\t\tclassInst = new classRef({ description: description, blox: blox });\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t\tconsole.error(\"Blox:: could not create behavior \" + className + \" for \" + label);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// I'm trying an idea of promoting all behavior functions into the functions collection\n\t\t\t\t// TODO could try use reflection\n\t\t\t\tfor (let label of Object.getOwnPropertyNames(Object.getPrototypeOf(classInst))) {\n\t\t\t\t\tlet handler = classInst[label];\n\t\t\t\t\tif (label.startsWith(\"on_\") && handler instanceof Function) {\n\t\t\t\t\t\tthis.functions.push({ label: label, handler: handler, owner: classInst });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// A pre-defined 'package' / instance already exists, send it some more data if possible\n\t\t\t\ttry {\n\t\t\t\t\tif (classInst.on_reset) {\n\t\t\t\t\t\tclassInst.on_reset({ description: description, blox: blox });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"Blox:: behavior doesn't have an on_reset: \" + className);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t\tconsole.error(\"Blox:: could not reset a behavior \" + className);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// behaviors back reference their blox\n\t\t\tclassInst.blox = blox;\n\t\t\t// behaviors back reference their construction document\n\t\t\tclassInst.description = description;\n\t\t\t// remember behavior\n\t\t\tif (isNew) {\n\t\t\t\tblox.behaviors[label] = classInst;\n\t\t\t\t// TEST an idea of flatter namespaces - inject behavior directly into blox scope for userland\n\t\t\t\tblox[label] = classInst;\n\t\t\t\t// tell local parties about the new behavior\n\t\t\t\tblox.on_event({ name: \"on_behavior_added\", behavior: classInst, blox: blox });\n\t\t\t}\n\n\t\t\t// pass this back\n\t\t\treturn classInst;\n\t\t} else {\n\t\t\t// TEST - make it easier for users to make documents by declaring children directly on the parent\n\t\t\tdescription.name = label;\n\t\t\tif (!this.behaviors.group) {\n\t\t\t\tconsole.error(\"Blox:: injecting children directly is missing a group\");\n\t\t\t}\n\t\t\tlet blox = this.behaviors.group.push(description);\n\t\t\treturn blox;\n\t\t}\n\t}\n\n\t///\n\t/// Moderately fancy query support for blox OR behaviors of a blox - always returning a group of behaviors\n\t///\n\t/// args may be a string, in which case a global namespace is searched for the blox.name\n\t/// args may be hash containing a 'property' in which case the assumption is to look for children behaviors with that field\n\t/// TODO extend as needed over time\n\t///\n\n\tquery(args) {\n\n\t\t// as a service to users, if a query is just a single string then search a global namespace for that blox.name\n\t\tif (typeof args == 'string') {\n\t\t\treturn global_blox_namespace[args];\n\t\t}\n\n\t\t// otherwise queries should be fancier hashes describing a possibly complex query, fail if this is not the case\n\t\tif (args.constructor != Object) {\n\t\t\tconsole.error(\"Blox query not understood\");\n\t\t\treturn null;\n\t\t}\n\n\t\t// some crude wildcard support; a name may be supplied to establish a parent blox to search in\n\n\t\tlet blox = this;\n\t\tif (args.name == \"*\") {\n\t\t\tlet keys = Object.keys(global_blox_namespace);\n\t\t\tlet which = Math.floor(keys.length * Math.random());\n\t\t\tblox = global_blox_namespace[keys[which]];\n\t\t} else if (args.name) {\n\t\t\tblox = global_blox_namespace[args.name];\n\t\t}\n\t\t// TODO ends with * and maybe regex\n\n\t\t// anything?\n\n\t\tif (!blox) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// return first or all?\n\t\tlet results = args.all ? [] : 0;\n\t\t// search local behaviors for a behavior with a given attribute and return said behavior\n\t\tif (args.property) {\n\t\t\tlet keys = Object.keys(blox.behaviors);\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tlet key = keys[i];\n\t\t\t\tlet value = blox.behaviors[key];\n\t\t\t\tif (value[args.property]) {\n\t\t\t\t\tif (!results) return value;\n\t\t\t\t\tresults.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// search local behaviors for a behavior of a kind and return said behavior\n\t\tif (args.instance) {\n\t\t\tlet keys = Object.keys(blox.behaviors);\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tlet key = keys[i];\n\t\t\t\tlet value = blox.behaviors[key];\n\t\t\t\tif (value instanceof args.instance) {\n\t\t\t\t\tif (!results) return value;\n\t\t\t\t\tresults.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n}\n\n//# sourceURL=webpack://BloxHack/../public/js/Blox.js?");

/***/ }),

/***/ "../public/lib/importModule.js":
/*!*************************************!*\
  !*** ../public/lib/importModule.js ***!
  \*************************************/
/*! exports provided: importModule, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"importModule\", function() { return importModule; });\nfunction toAbsoluteURL(url) {\n  const a = document.createElement(\"a\");\n  a.setAttribute(\"href\", url); // <a href=\"hoge.html\">\n  return a.cloneNode(false).href; // -> \"http://example.com/hoge.html\"\n}\n\nfunction importModule(url) {\n  return new Promise((resolve, reject) => {\n    const vector = \"$importModule$\" + Math.random().toString(32).slice(2);\n    const script = document.createElement(\"script\");\n    const destructor = () => {\n      delete window[vector];\n      script.onerror = null;\n      script.onload = null;\n      script.remove();\n      URL.revokeObjectURL(script.src);\n      script.src = \"\";\n    };\n    script.defer = \"defer\";\n    script.type = \"module\";\n    script.onerror = () => {\n      reject(new Error(`Failed to import: ${url}`));\n      destructor();\n    };\n    script.onload = () => {\n      resolve(window[vector]);\n      destructor();\n    };\n    const absURL = toAbsoluteURL(url);\n    const loader = `import * as m from \"${absURL}\"; window.${vector} = m;`; // export Module\n    const blob = new Blob([loader], { type: \"text/javascript\" });\n    script.src = URL.createObjectURL(blob);\n\n    document.head.appendChild(script);\n  });\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (importModule);\n\n//# sourceURL=webpack://BloxHack/../public/lib/importModule.js?");

/***/ }),

/***/ "./src/expose-behaviors.js":
/*!*********************************!*\
  !*** ./src/expose-behaviors.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _public_js_BehaviorRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../public/js/BehaviorRenderer.js */ \"../public/js/BehaviorRenderer.js\");\n/* harmony import */ var _public_js_BehaviorCamera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../public/js/BehaviorCamera.js */ \"../public/js/BehaviorCamera.js\");\n/* harmony import */ var _public_js_BehaviorLight_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../public/js/BehaviorLight.js */ \"../public/js/BehaviorLight.js\");\n/* harmony import */ var _public_js_BehaviorMesh_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../public/js/BehaviorMesh.js */ \"../public/js/BehaviorMesh.js\");\n/* harmony import */ var _public_js_BehaviorSky_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../public/js/BehaviorSky.js */ \"../public/js/BehaviorSky.js\");\n/* harmony import */ var _public_js_BehaviorHeart_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../public/js/BehaviorHeart.js */ \"../public/js/BehaviorHeart.js\");\n/* harmony import */ var _public_js_BehaviorText_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../public/js/BehaviorText.js */ \"../public/js/BehaviorText.js\");\n/* harmony import */ var _public_js_BehaviorTextPanel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../public/js/BehaviorTextPanel.js */ \"../public/js/BehaviorTextPanel.js\");\n/* harmony import */ var _public_js_BehaviorIntent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../public/js/BehaviorIntent.js */ \"../public/js/BehaviorIntent.js\");\n/* harmony import */ var _public_js_BehaviorPhysics_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../public/js/BehaviorPhysics.js */ \"../public/js/BehaviorPhysics.js\");\n/* harmony import */ var _public_js_BehaviorCollide_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../public/js/BehaviorCollide.js */ \"../public/js/BehaviorCollide.js\");\n/* harmony import */ var _public_js_BehaviorOrbit_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../public/js/BehaviorOrbit.js */ \"../public/js/BehaviorOrbit.js\");\n/* harmony import */ var _public_js_BehaviorWalk_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../public/js/BehaviorWalk.js */ \"../public/js/BehaviorWalk.js\");\n/* harmony import */ var _public_js_BehaviorBounce_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../public/js/BehaviorBounce.js */ \"../public/js/BehaviorBounce.js\");\n/* harmony import */ var _public_js_BehaviorParticles_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../public/js/BehaviorParticles.js */ \"../public/js/BehaviorParticles.js\");\n/* harmony import */ var _public_js_BehaviorProton_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../public/js/BehaviorProton.js */ \"../public/js/BehaviorProton.js\");\n/* harmony import */ var _public_js_BehaviorEmitter_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../public/js/BehaviorEmitter.js */ \"../public/js/BehaviorEmitter.js\");\n\n// custom hack version\nclass BehaviorScene extends THREE.Scene {\n    constructor(args) {\n        console.log('@@ BehaviorScene(): hello from custom version');\n        THREE.Loader.extractUrlBase = THREE.LoaderUtils.extractUrlBase;\n        var props = args.description || {};\n        var blox = args.blox;\n        super();\n        // this.renderer = blox.add({label:\"renderer\"})\n        // this.camera = blox.add({label:\"camera\"})\n        // this.renderer.reset(this,this.camera,this.camera)\n        //========\n        // emulate updateScene() of BehaviorRenderer.js\n        this.update = function (time) {\n            // console.log('@@ updateScene(): time:', time);\n            blox.on_event({\n                blox: blox,\n                name: \"on_tick\",\n                interval: time\n            });\n        };\n    }\n    on_blox_added(args) {\n        console.log('@@ BehaviorScene.on_blox_added() hello');\n        var scene = this;\n        var child = args.child;\n        var objects = child.query({ instance: THREE.Object3D, all: true });\n        objects.forEach(function (value) {\n            if (!scene) console.error(\"scene is bad\");\n            if (!scene) return;\n            scene.add(value);\n            if (value instanceof THREE.PerspectiveCamera) {\n                // this.renderer.reset(this,value,value)\n            }\n        });\n    }\n}\n\n// Basic\n\n// import {BehaviorScene} from '../../public/js/BehaviorScene.js'; // use custom version above\n\n\n\n// Some objects\n\n\n\n\n// Motion and physics, some of this may merge together\n\n\n\n// Motion models for player\n // TODO this one really needs to be rewritten\n\n// Some other behaviors\n\n\n\n\n\nObject.assign(window, {\n    // Basic\n    BehaviorRenderer: _public_js_BehaviorRenderer_js__WEBPACK_IMPORTED_MODULE_0__[\"BehaviorRenderer\"],\n    BehaviorScene: BehaviorScene,\n    BehaviorCamera: _public_js_BehaviorCamera_js__WEBPACK_IMPORTED_MODULE_1__[\"BehaviorCamera\"],\n    BehaviorLight: _public_js_BehaviorLight_js__WEBPACK_IMPORTED_MODULE_2__[\"BehaviorLight\"],\n    BehaviorMesh: _public_js_BehaviorMesh_js__WEBPACK_IMPORTED_MODULE_3__[\"BehaviorMesh\"],\n    // Some objects\n    BehaviorSky: _public_js_BehaviorSky_js__WEBPACK_IMPORTED_MODULE_4__[\"BehaviorSky\"],\n    BehaviorHeart: _public_js_BehaviorHeart_js__WEBPACK_IMPORTED_MODULE_5__[\"BehaviorHeart\"],\n    BehaviorText: _public_js_BehaviorText_js__WEBPACK_IMPORTED_MODULE_6__[\"BehaviorText\"],\n    BehaviorTextPanel: _public_js_BehaviorTextPanel_js__WEBPACK_IMPORTED_MODULE_7__[\"BehaviorTextPanel\"],\n    // Motion and physics, some of this may merge together\n    BehaviorIntent: _public_js_BehaviorIntent_js__WEBPACK_IMPORTED_MODULE_8__[\"BehaviorIntent\"],\n    BehaviorPhysics: _public_js_BehaviorPhysics_js__WEBPACK_IMPORTED_MODULE_9__[\"BehaviorPhysics\"], BehaviorPhysical: _public_js_BehaviorPhysics_js__WEBPACK_IMPORTED_MODULE_9__[\"BehaviorPhysical\"],\n    BehaviorCollide: _public_js_BehaviorCollide_js__WEBPACK_IMPORTED_MODULE_10__[\"BehaviorCollide\"],\n    // Motion models for player\n    BehaviorOrbit: _public_js_BehaviorOrbit_js__WEBPACK_IMPORTED_MODULE_11__[\"BehaviorOrbit\"],\n    BehaviorWalk: _public_js_BehaviorWalk_js__WEBPACK_IMPORTED_MODULE_12__[\"BehaviorWalk\"],\n    // Some other behaviors\n    BehaviorLine: _public_js_BehaviorBounce_js__WEBPACK_IMPORTED_MODULE_13__[\"BehaviorLine\"], BehaviorBounce: _public_js_BehaviorBounce_js__WEBPACK_IMPORTED_MODULE_13__[\"BehaviorBounce\"], BehaviorOscillate: _public_js_BehaviorBounce_js__WEBPACK_IMPORTED_MODULE_13__[\"BehaviorOscillate\"], BehaviorWander: _public_js_BehaviorBounce_js__WEBPACK_IMPORTED_MODULE_13__[\"BehaviorWander\"], BehaviorStare: _public_js_BehaviorBounce_js__WEBPACK_IMPORTED_MODULE_13__[\"BehaviorStare\"],\n    BehaviorParticles: _public_js_BehaviorParticles_js__WEBPACK_IMPORTED_MODULE_14__[\"BehaviorParticles\"],\n    BehaviorProton: _public_js_BehaviorProton_js__WEBPACK_IMPORTED_MODULE_15__[\"BehaviorProton\"],\n    BehaviorEmitter: _public_js_BehaviorEmitter_js__WEBPACK_IMPORTED_MODULE_16__[\"BehaviorEmitter\"]\n});\n\n//# sourceURL=webpack://BloxHack/./src/expose-behaviors.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _expose_behaviors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expose-behaviors.js */ \"./src/expose-behaviors.js\");\n/* harmony import */ var _public_js_Blox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../public/js/Blox.js */ \"../public/js/Blox.js\");\n\n// functionality --\n// 1) workaround eval(className) errors in Blox.add() due to webpack'ish side effect\n//    kludge for usage via <script src=\"../hack/lib/blox-hack.js\"></script>\n// 2) this exposes a customized BehaviorScene class; do make sure\n//    import {BehaviorScene} is disabled blox.js\n\n\n\n//import { Blox } from '../../public/js/Blox-j.js';\n\n// note - disabled eslint-loader in webpack.config.js for semicolon workaround\n// note - per https://stackoverflow.com/questions/36577683/babel-error-class-constructor-foo-cannot-be-invoked-without-new\n//        in .babelrc, added \"exclude\": [\"transform-es2015-classes\"]\n// note - 'npm run build' is failing due to uglify --\n//         ERROR in blox-hack.min.js from UglifyJs\n//         Unexpected token: name «BehaviorMesh», expected: punc «;» [blox-hack.min.js:111,6]\n//     per https://github.com/webpack-contrib/uglifyjs-webpack-plugin/issues/78\n//     workaround is: npm i -D uglifyjs-webpack-plugin@beta\n//     after that LGTM\n\nclass BloxHack extends _public_js_Blox_js__WEBPACK_IMPORTED_MODULE_1__[\"Blox\"] {\n    constructor(args) {\n        var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        super(args, parent);\n        console.log('@@ setting onBehaviorScene');\n        this.onBehaviorScene = data.onBehaviorScene;\n    }\n\n    // override\n    add(args) {\n        console.log('@@ args:', args);\n        var out = super.add(args);\n        if (args.label === 'scene') {\n            console.log('@@ out for scene:', out);\n            if (this.onBehaviorScene) {\n                this.onBehaviorScene(out);\n            }\n        }\n\n        return out;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (BloxHack);\n\n//# sourceURL=webpack://BloxHack/./src/index.js?");

/***/ })

/******/ })["default"];
});